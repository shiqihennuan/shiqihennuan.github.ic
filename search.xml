<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[七天搞定node.js---第七天]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%AD%A6%E4%B9%A0node.js%E7%9A%84%E7%AC%AC%E4%B8%83%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[自学node.js第七天的笔记，差点以为要烂尾了~ 中间件http://expressjs.com/en/guide/using-middleware.html中间件的本质就是一个请求处理方法，我们把用户从请求到响应的整个过程分发到多个中间件中去处理，这样做的目的是提高代码的灵活性，动态可扩展的。 同一个请求所经过的中间件都是同一个请求对象和响应对象 应用程序级别中间件万能匹配（不关心任何请求路劲和请求方法）：1234app.use(function(req,res,next)&#123; console.log(&apos;Time:&apos;,Date.now()) next()&#125;) 只要是以 /xxx/ 开头的：1234app.use(&apos;/a&apos;,function(req,res,next)&#123; console.log(&apos;Time:&apos;,Date.now()) next()&#125;) 路由级别中间件get:123app.get(&apos;/&apos;,function(req,res,next)&#123;res.send(&apos;hello world!&apos;)&#125;) post:123app.post(&apos;/&apos;,function(req,res,next)&#123;res.send(&apos;got a post request&apos;)&#125;) put:123app.put(&apos;/user&apos;,function(req,res,next)&#123;res.send(&apos;got a put request at /user&apos;)&#125;) delete:123app.get(&apos;/user&apos;,function(req,res,next)&#123;res.send(&apos;got a delete request at /user&apos;)&#125;) 错误处理中间件1234app.use(function(err,req,res,next)&#123;console.error(err.stack)res.status(500).send(&apos;Something broke!&apos;)&#125;) 内置中间件 express.static express.json express.urlencoded 第三方中间件http://expressjs.com/en/resources/middleware.html body-parser compression cookie-parser morgan response-time serve-static session 源代码可以去我的 github 克隆]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七天搞定node.js---第六天]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%AD%A6%E4%B9%A0node.js%E7%9A%84%E7%AC%AC%E5%85%AD%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[自学node.js第六天的笔记。 path 路径操作模块参考文档：https://nodejs.org/dist/latest-v9.x/docs/api/path.html path.basename 获取一个路径的文件名（默认包含扩展名） path.dirname 获取一个路径中的目录部分 path.extname 获取一个路径中的扩展名部分 path.parse 把一个路径转为对象 root 根路径 dir 目录 base 包含后缀的文件名 ext 后缀名 name 不包含后缀的文件名 path.join 当你需要进行路径拼接的时候，推荐使用这个方法 path.isAbsolute 判断一个路径是否是绝对路径 Node 中的其他成员在每个模块中，除了 require、exports 等模块相关 API 之外，还有两个特殊的成员： __dirname 可以用来获取当前文件模块所属目录的绝对路径 动态获取 __filename 可以用来获取当前文件的绝对路径 动态获取 用 node 做后台实现了一个简易版的博客系统，源码都在我的github 源代码可以去我的 github 克隆]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七天搞定node.js---第五天]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%AD%A6%E4%B9%A0node.js%E7%9A%84%E7%AC%AC%E4%BA%94%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[自学node.js第五天的笔记。 异步编程setTimeout()是一个异步api1234567891011function f1() &#123; console.log(1) setTimeout(function() &#123; console.log(2) &#125;, 2000) console.log(3)&#125;f1()// 结果：1 3 2 不成立的情况：1234567891011121314151617function f1(x, y) &#123; var ret console.log(1) setTimeout(function() &#123; ret = x + y console.log(2) &#125;, 2000) console.log(3) return ret&#125;console.log(f1(10 + 20)) =&gt;undefined//输出结果：// 1// 3// undefined// 2 使用回调函数：123456789function f1(x, y, callback) &#123; setTimeout(function() &#123; var ret = x + y callback(ret) &#125;, 2000)&#125;f1(10, 10, function(ret) &#123; console.log(ret)&#125;) 2秒后得到结果：20 封装ajax,理解回调函数12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;ajax&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; function get(url, callback) &#123; var oReq = new XMLHttpRequest() oReq.onload = function() &#123; callback(oReq.responseText) &#125; oReq.open(&quot;get&quot;, url, true) oReq.send() &#125; get(&apos;data.json&apos;, function(data) &#123; console.log(data) &#125;)&lt;/script&gt;&lt;/html&gt; MongoDB安装 官网下载：https://www.mongodb.com/download-center/community 配置环境变量 最后终端输入mongod --version查看是否安装成功 启动和关闭数据表启动：1234// mongodb 默认使用执行 mongod 命令所处盘符根目录下的 /data/db 作为自己数据存储目录// 所以在第一次执行该命令之前先自己手动新建一个 /data/dbmongod 如果想要修改默认的数据库存储目录，可以：1mongod --dbpath-数据库存储目录路径 停止:1在开启服务的控制台，直接 ctrl+c 就能停止。 连接和退出数据库连接：123// 默认连接本机的 MongoDB 服务mongo 退出：1exit 基本命令 show dbs 查看显示所有数据库 db 查看当前操作的数据库 use 数据库名称 切换到指定的数据库（如果没有会新建） 插入数据 mongoose 官网：https://mongoosejs.com/ 官方指南：https://mongoosejs.com/docs/guide.html 官方 API 文档：https://mongoosejs.com/docs/api.html MongoDB 数据库的基本概念 可以有多个数据库 一个数据库中可以有多个集合(表) 一个集合中可以有多个文档(表记录) 文档结构很灵活，没有任何限制 MongoDB 非常灵活，不需要想 MySQL 一样先创建数据库、表、设计表结构 当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了 一切都由 MongoDB 来帮你自动完成建库建表 12345678910111213141516171819&#123; qq:&#123; users:[ &#123;name:&apos;木槿0&apos;,age:15&#125;, &#123;name:&apos;木槿1&apos;,age:17&#125;, &#123;name:&apos;木槿2&apos;,age:19&#125; ], products:[ ], ...... &#125;, taobao:&#123; &#125;, baidu:&#123; &#125;&#125; 起步安装：1npm i mongoose hello world:1234567891011121314151617181920212223242526var mongoose = require(&apos;mongoose&apos;);// 连接 MongoDB 数据库mongoose.connect(&apos;mongodb://localhost/test&apos;, &#123; useMongoClient: true &#125;);mongoose.Promise = global.Promise;// 创建一个模型// 就是在设计数据库// MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了// mongoose 这个包就可以让你的设计编写过程变的非常的简单var Cat = mongoose.model(&apos;Cat&apos;, &#123; name: String &#125;);for (var i = 0; i &lt; 100; i++) &#123; // 实例化一个 Cat var kitty = new Cat(&#123; name: &apos;喵喵&apos; + i &#125;); // 持久化保存 kitty 实例 kitty.save(function(err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;meow&apos;); &#125; &#125;);&#125; 官方指南设计 Schema 发布 Model123456789101112131415161718192021222324252627282930313233343536var mongoose = require(&apos;mongoose&apos;)var Schema = mongoose.Schema // 1. 连接数据库 // 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect(&apos;mongodb://localhost/itcast&apos;)// 2. 设计文档结构（表结构）// 字段名称就是表结构中的属性名称// 约束的目的是为了保证数据的完整性，不要有脏数据var userSchema = new Schema(&#123; username: &#123; type: String, required: true // 不能为空 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;)//3.将文档结构发表为模型// mongoose.model 方法就是用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称// mongoose 会自动将大写名词的字符串生成小写复数的集合名词// 例如这里的 User 最终会变为 users 集合名称// 第二个参数：架构 Schema// 返回对象：模型构造函数var User = mongoose.model(&apos;User&apos;, userSchema)// 4.当我们有了模型构造函数之后，就可以使用这个构造函数对 users 集合中的数据为所欲为了（增删改查） 增加数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var mongoose = require(&apos;mongoose&apos;)var Schema = mongoose.Schema // 1. 连接数据库 // 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect(&apos;mongodb://localhost/itcast&apos;)// 2. 设计文档结构（表结构）// 字段名称就是表结构中的属性名称// 约束的目的是为了保证数据的完整性，不要有脏数据var userSchema = new Schema(&#123; username: &#123; type: String, required: true // 不能为空 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;)//3.将文档结构发表为模型// mongoose.model 方法就是用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称// mongoose 会自动将大写名词的字符串生成小写复数的集合名词// 例如这里的 User 最终会变为 users 集合名称// 第二个参数：架构 Schema// 返回对象：模型构造函数var User = mongoose.model(&apos;User&apos;, userSchema)// 4.当我们有了模型构造函数之后，就可以使用这个构造函数对 users 集合中的数据为所欲为了（增删改查）var admin = new User(&#123; username: &apos;admin&apos;, password: &apos;123456&apos;, email: &apos;xq-ambition@qq.com&apos;&#125;)admin.save(function(err, ret) &#123; if (err) &#123; console.log(&apos;保存失败~&apos;) &#125; else &#123; console.log(&apos;保存成功&apos;) console.log(ret) &#125;&#125;) 查询数据查询所有：1234567User.find(function(err, ret) &#123; if (err) &#123; console.log(&apos;查询失败~&apos;) &#125; else &#123; console.log(ret) &#125;&#125;) 按条件查询所有：123456789User.find(&#123; username: &apos;莫子谦&apos; //条件&#125;, function(err, ret) &#123; if (err) &#123; console.log(&apos;查询失败~&apos;) &#125; else &#123; console.log(ret) &#125;&#125;) 按条件查询单个：12345678910User.findOne(&#123; // 查询符合条件的一个 username: &apos;莫子谦&apos;, //条件 password: &apos;xuqian&apos;&#125;, function(err, ret) &#123; if (err) &#123; console.log(&apos;查询失败~&apos;) &#125; else &#123; console.log(ret) &#125;&#125;) 删除数据根据条件删除所有：12345678910User.remove(&#123; username: &apos;莫子谦&apos; //删除条件&#125;, function(err, ret) &#123; if (err) &#123; console.log(&apos;删除失败~&apos;) &#125; else &#123; console.log(&apos;删除成功&apos;) console.log(ret) &#125;&#125;) 根据条件删除一个：1Model.findOneAndRemove(conditions,[options],[callback]) 根据 ID 删除一个1Model.findByIdAndRemove(id,[options],[callback]) 更新数据根据条件更新所有：1Model.update(conditions,doc,[options],[callback]) 根据指定条件更新一个：1Model.findOneAndUpdate(conditions,[updata],[opyions],[callback]) 根据 ID 更新一个:12345678910User.findByIdAndUpdate(&apos;5d83539e2167524ff85cae99&apos;, &#123; //需要更改数据的id //需要更新的内容 password: &apos;9090909&apos;&#125;, function(err, ret) &#123; if (err) &#123; console.log(&apos;更新数据失败~&apos;) &#125; else &#123; console.log(&apos;更新数据成功&apos;) &#125;&#125;) 使用 node 操作 MySQL 数据库安装：1npm install mysql 整体感知：12345678910111213141516171819202122232425var mysql = require(&apos;mysql&apos;);// 1.创建连接var connection = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;root&apos;, password: &apos;&apos;, database: &apos;users&apos;&#125;);// 2.连接数据库connection.connect();//3.执行数据库操作connection.query(&apos;SELECT * FROM `students`&apos;, function(error, results, fields) &#123; if (error) throw error; console.log(&apos;The solution is: &apos;, results);&#125;);// connection.query(&apos;INSERT INTO students VALUES(null,&quot;admin&quot;,&quot;123456&quot;)&apos;, function(error, results, fields) &#123;// if (error) throw error;// console.log(&apos;The solution is: &apos;, results);// &#125;);//4. 关闭连接connection.end(); Promisecallback hell: 12345678910111213141516171819202122232425262728293031323334var fs = require(&apos;fs&apos;)fs.readFile(&apos;./data/a.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // return console.log(&apos;读取失败&apos;) // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data)&#125;)fs.readFile(&apos;./data/b.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // return console.log(&apos;读取失败&apos;) // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data)&#125;)fs.readFile(&apos;./data/c.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // return console.log(&apos;读取失败&apos;) // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data)&#125;) 不一定谁先谁后，同等文件大小取决于计算机的调度机制，文件越大读取越慢。 所以通过回调嵌套的方式来保证执行顺序。1234567891011121314151617181920212223242526272829303132var fs = require(&apos;fs&apos;)fs.readFile(&apos;./data/a.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // return console.log(&apos;读取失败&apos;) // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data) fs.readFile(&apos;./data/b.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // return console.log(&apos;读取失败&apos;) // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data) fs.readFile(&apos;./data/c.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // return console.log(&apos;读取失败&apos;) // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data) &#125;) &#125;)&#125;) 为了解决多次嵌套，最终难以维护的问题，在 EcmaScript6 中新增了一个 API：Promise参考文档：http://es6.ruanyifeng.com/#docs/promise Promise 基本语法：1234567891011121314151617181920212223242526272829var fs = require(&apos;fs&apos;) // Promise 是一个构造函数// 使用：// 1.创建 Promise 容器，给别人一个承诺。// Promise 容器一旦被创建，就开始执行里面的代码。var p1 = new Promise(function(resolve, reject) &#123; fs.readFile(&apos;./data/a.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // console.log(err) reject(err) &#125; else &#123; // console.log(data) resolve(data) &#125; &#125;)&#125;)// then 方法接收的 function 就是容器中的 resolve 函数p1.then(function(data) &#123; console.log(data)&#125;, function(err) &#123; console.log(&apos;读取文件失败~&apos;, err)&#125;) Promise 解决回调地狱 嵌套问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var fs = require(&apos;fs&apos;) // Promise 是一个构造函数// 使用：// 1.创建 Promise 容器，给别人一个承诺。// Promise 容器一旦被创建，就开始执行里面的代码。var p1 = new Promise(function(resolve, reject) &#123; fs.readFile(&apos;./data/a.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // console.log(err) reject(err) &#125; else &#123; // console.log(data) resolve(data) &#125; &#125;)&#125;)var p2 = new Promise(function(resolve, reject) &#123; fs.readFile(&apos;./data/b.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // console.log(err) reject(err) &#125; else &#123; // console.log(data) resolve(data) &#125; &#125;)&#125;)var p3 = new Promise(function(resolve, reject) &#123; fs.readFile(&apos;./data/c.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // console.log(err) reject(err) &#125; else &#123; // console.log(data) resolve(data) &#125; &#125;)&#125;)// then 方法接收的 function 就是容器中的 resolve 函数p1.then(function(data) &#123; console.log(data) return p2&#125;, function(err) &#123; console.log(&apos;读取文件失败~&apos;, err)&#125;).then(function(data) &#123; console.log(data) return p3&#125;, function(err) &#123; console.log(&apos;读取文件失败~&apos;, err)&#125;).then(function(data) &#123; console.log(data)&#125;, function(err) &#123; console.log(&apos;读取文件失败~&apos;, err)&#125;) 封装 Promise-api (readFile)12345678910111213141516171819202122232425262728var fs = require(&apos;fs&apos;)function pReadFile(filePath) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(filePath, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; // console.log(err) reject(err) &#125; else &#123; // console.log(data) resolve(data) &#125; &#125;) &#125;)&#125;pReadFile(&apos;./data/a.txt&apos;) .then(function(data) &#123; console.log(data) return pReadFile(&apos;./data/b.txt&apos;) &#125;) .then(function(data) &#123; console.log(data) return pReadFile(&apos;./data/c.txt&apos;) &#125;) .then(function(data) &#123; console.log(data) &#125;) Promise使用场景1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;promise应用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;00-callback.js&quot; method=&quot;get&quot; id=&quot;user_form&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/template&quot; id=&quot;tpl&quot;&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.username&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;年龄&lt;/label&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.age&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;用户名&lt;/label&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &#123;&#123;each jobs&#125;&#125; &#123;&#123;if user.job === $value.id&#125;&#125; &lt;option value=&quot;&#123;&#123;$value.id&#125;&#125;&quot; selected&gt;&#123;&#123;$value.name&#125;&#125;&lt;/option&gt; &#123;&#123;else&#125;&#125; &lt;option value=&quot;&#123;&#123;$value.id&#125;&#125;&quot;&gt;&#123;&#123;$value.name&#125;&#125;&lt;/option&gt; &#123;&#123;/if&#125;&#125; &#123;&#123;/each&#125;&#125; &lt;/select&gt; &lt;/div&gt; &lt;/script&gt;&lt;/body&gt;&lt;script src=&quot;./node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./node_modules/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 嵌套写法 // get(&apos;http://localhost:3000/users/4&apos;, function(userData) &#123; // get(&apos;http://localhost:3000/jobs&apos;, function(jobsData) &#123; // // console.log(userData, jobsData) // var htmlStr = template(&apos;tpl&apos;, &#123; // user: JSON.parse(userData), // jobs: JSON.parse(jobsData) // &#125;) // // console.log(htmlStr) // document.querySelector(&apos;#user_form&apos;).innerHTML = htmlStr // &#125;) // &#125;) var data = &#123;&#125; $.get(&apos;http://localhost:3000/users/4&apos;) .then(function(userData) &#123; data.user = userData return $.get(&apos;http://localhost:3000/jobs&apos;) &#125;) .then(function(jobsData) &#123; data.jobs = jobsData // console.log(data) var htmlStr = template(&apos;tpl&apos;, data) document.querySelector(&apos;#user_form&apos;).innerHTML = htmlStr &#125;) function get(url, callback) &#123; var oReq = new XMLHttpRequest() oReq.onload = function() &#123; callback(oReq.responseText) &#125; oReq.open(&quot;get&quot;, url, true) oReq.send() &#125;&lt;/script&gt;&lt;/html&gt; 源代码可以去我的 github 克隆]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七天搞定node.js---第四天]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%AD%A6%E4%B9%A0node.js%E7%9A%84%E7%AC%AC%E5%9B%9B%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[自学node.js第四天的笔记。 知识点 Express 基于文件做一套 CRUD 模块标识中的 / 和文件操作路径中的 /文件操作路径：12345678910111213// 在文件操作的相对路径中// ./data/a.txt 相对于当前目录// data/a.txt 相对于当前目录// /data/a.txt 绝对路径,当前文件模块所处磁盘根目录// c:/xx/xx... 绝对路径// fs.readFile(&apos;/data/a.txt&apos;, function(err, data) &#123;// if (err) &#123;// // console.log(err)// // Error: ENOENT: no such file or directory, open &apos;C:\data\a.txt&apos;// return console.log(&apos;读取失败&apos;)// &#125;// console.log(data.toString())// &#125;) 模块操作路径：12345678//这里如果忽略了 . 则也是去磁盘根目录找 require(&apos;/data/foo.js&apos;)// 相对路径require(&apos;./data/foo.js&apos;)// 模块加载的路径中的相对路径不能省略 ./ Express原生的 http 在某些方面表现不足以应对我们的开发需求,所以我们就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码更高度统一。 在 Node 中，有很多 Web 开发框架，这里以 express 为主。 官网：http://expressjs.com/ 起步安装：1npm install --save express hello world123456789101112131415161718var express = require(&apos;express&apos;)//1.创建 appvar app = express()app.get(&apos;/&apos;, function(req, res) &#123; // res.end(&apos;hello world&apos;) res.send(&apos;you see see one day day&apos;)&#125;)app.get(&apos;/login&apos;, function(req, res) &#123; // res.end(&apos;hello world&apos;) res.send(&apos;login page&apos;)&#125;)app.listen(3000, function() &#123; console.log(&apos;express app is running ~&apos;)&#125;) 基本路由GET：123app.get(&apos;/&apos;,function(req,res)&#123; res.send(&apos;Hello World~&apos;)&#125;) POST:123app.post(&apos;/&apos;,function(req,res)&#123; res.send(&apos;Got a POST request~&apos;)&#125;) 静态服务1234567891011// public里面的具体资源app.use(express.static(&apos;public&apos;))// files里面的具体资源app.use(express.static(&apos;files&apos;))// /public/public里面的具体资源app.use(&apos;/public/&apos;,express.static(&apos;public&apos;))// /static/public里面的具体资源app.use(&apos;/static/&apos;,express.static(&apos;public&apos;))app.use(&apos;/static/&apos;,express.static(path.join(__dirname,&apos;public&apos;))) 在 Express 中配置使用 art-templat模板引擎 art-template - github仓库 art-template - 官方文档 安装12npm install --save art-templatenpm install --save express-art-template 配置1app.engine(&apos;art&apos;, require(&apos;express-art-template&apos;)); 使用123456app.get(&apos;/&apos;,function(req,res)&#123; // express 默认会去项目中的 views 目录中找 index.html res.render(&apos;index.html&apos;,&#123; title:&apos;hello world~&apos; &#125;)&#125;) 修改默认的 views 视图渲染存储目录：1app.set(&apos;views&apos;,&apos;render函数的默认路径&apos;) 在 Express 中获取表单 GET 请求参数express 内置了一个 API ,可以直接通过 req.query来获取1req.query 在 Express 获取表单 POST 请求体数据在 Express 中没有内置获取表单 POST 请求体的 API ,需要使用一个第三方包：body-parser 安装1npm install body-parser 配置1234567891011121314var express = require(&apos;express&apos;)// 0.引包var bodyParser = require(&apos;body-parser&apos;)var app = express()// 配置 body-parser// 只要加入这个配置，则在 req 请求对象上会多出来一个属性：body// 也就是说可以直接通过 req.body 来获取表单 POST 请求体数据了// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json()) 使用123456app.use(function (req, res) &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;) res.write(&apos;you posted:\n&apos;)// 通过 req.body 来获取表单 POST 请求体数据了 res.end(JSON.stringify(req.body, null, 2))&#125;) 修改完代码自动重启服务器使用第三方命令行工具：nodemon来解决频繁修改代码手动重启服务器问题nodemon 是一个基于 Node.js开发的一个第三方命令行工具，在使用的时候需要独立安装：123// 在任意目录执行都行// 也就是说，所有需要 --global 来安装的包都可以在任意目录执行npm install --global nodemon 安装完毕之后，使用：12345//以前node app.js//使用nodemonnodemon app.js 只要通过nodemon app.js启动的服务，则它会监事你的文件变化，当文件发生变化的时候，自动帮你重启服务器。 基于文件完成CRUD(增删改查),在bootstarp官网偷的一套模板~index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;../../favicon.ico&quot;&gt; &lt;title&gt;Dashboard Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;/node_modules/bootstrap/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;/public/css/dashboard.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbar&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;navbar&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Project name&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Dashboard&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Settings&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Help&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-right&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search...&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3 col-md-2 sidebar&quot;&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Overview &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Reports&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Analytics&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Export&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item again&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;One more nav&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Another nav item&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;More navigation&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item again&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;One more nav&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Another nav item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main&quot;&gt; &lt;h1 class=&quot;page-header&quot;&gt;Dashboard&lt;/h1&gt; &lt;div class=&quot;row placeholders&quot;&gt; &lt;div class=&quot;col-xs-6 col-sm-3 placeholder&quot;&gt; &lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;200&quot; height=&quot;200&quot; class=&quot;img-responsive&quot; alt=&quot;Generic placeholder thumbnail&quot;&gt; &lt;h4&gt;Label&lt;/h4&gt; &lt;span class=&quot;text-muted&quot;&gt;Something else&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3 placeholder&quot;&gt; &lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;200&quot; height=&quot;200&quot; class=&quot;img-responsive&quot; alt=&quot;Generic placeholder thumbnail&quot;&gt; &lt;h4&gt;Label&lt;/h4&gt; &lt;span class=&quot;text-muted&quot;&gt;Something else&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3 placeholder&quot;&gt; &lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;200&quot; height=&quot;200&quot; class=&quot;img-responsive&quot; alt=&quot;Generic placeholder thumbnail&quot;&gt; &lt;h4&gt;Label&lt;/h4&gt; &lt;span class=&quot;text-muted&quot;&gt;Something else&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3 placeholder&quot;&gt; &lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;200&quot; height=&quot;200&quot; class=&quot;img-responsive&quot; alt=&quot;Generic placeholder thumbnail&quot;&gt; &lt;h4&gt;Label&lt;/h4&gt; &lt;span class=&quot;text-muted&quot;&gt;Something else&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;h2 class=&quot;sub-header&quot;&gt;Section title&lt;/h2&gt; &lt;a href=&quot;/students/news&quot; class=&quot;btn btn-success&quot;&gt;添加&lt;/a&gt; &lt;div class=&quot;table-responsive&quot;&gt; &lt;table class=&quot;table table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;爱好&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;&#123;each students&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;$value.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.gender&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.hobbies&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/students/edit?id=&#123;&#123;$value.id&#125;&#125;&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;/students/delete?id=&#123;&#123;$value.id&#125;&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; news.html页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;../../favicon.ico&quot;&gt; &lt;title&gt;Dashboard Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;/node_modules/bootstrap/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;/public/css/dashboard.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbar&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;navbar&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Project name&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Dashboard&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Settings&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Help&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-right&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search...&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3 col-md-2 sidebar&quot;&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Overview &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Reports&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Analytics&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Export&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item again&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;One more nav&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Another nav item&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;More navigation&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item again&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;One more nav&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Another nav item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main&quot;&gt; &lt;h2 class=&quot;sub-header&quot;&gt;添加学生&lt;/h2&gt; &lt;form action=&quot;/students/news&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;&quot; placeholder=&quot;name&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;性别：&lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;&quot; value=&quot;0&quot;&gt; 男 &lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;&quot; value=&quot;1&quot;&gt; 女 &lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;年龄：&lt;/label&gt; &lt;input type=&quot;number&quot; id=&quot;&quot; name=&quot;age&quot; class=&quot;form-control&quot; placeholder=&quot; age&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group &quot;&gt; &lt;label for=&quot; &quot;&gt;爱好：&lt;/label&gt; &lt;input type=&quot;text &quot; id=&quot; &quot; name=&quot;hobbies&quot; class=&quot;form-control &quot; placeholder=&quot;hobbies &quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit &quot; class=&quot;btn btn-default &quot;&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; edit.html页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;../../favicon.ico&quot;&gt; &lt;title&gt;Dashboard Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;/node_modules/bootstrap/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;/public/css/dashboard.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbar&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;navbar&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Project name&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Dashboard&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Settings&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Help&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-right&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search...&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3 col-md-2 sidebar&quot;&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/students&quot;&gt;学生管理 &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Reports&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Analytics&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Export&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item again&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;One more nav&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Another nav item&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;More navigation&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Nav item again&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;One more nav&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Another nav item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main&quot;&gt; &lt;h2 class=&quot;sub-header&quot;&gt;编辑学生&lt;/h2&gt; &lt;form action=&quot;/students/edit&quot; method=&quot;post&quot;&gt; &lt;!-- 用来放一些不希望被用户看见，但是需要被提交到服务端的数据 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&#123;&#123; student.id &#125;&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;&quot; name=&quot;name&quot; required minlength=&quot;2&quot; maxlength=&quot;10&quot; value=&quot;&#123;&#123; student.name &#125;&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;性别&lt;/label&gt; &lt;div&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;&quot; value=&quot;0&quot; checked&gt; 男 &lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;&quot; value=&quot;1&quot;&gt; 女 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;年龄&lt;/label&gt; &lt;input class=&quot;form-control&quot; type=&quot;number&quot; id=&quot;&quot; name=&quot;age&quot; value=&quot;&#123;&#123; student.age &#125;&#125;&quot; required min=&quot;1&quot; max=&quot;150&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;爱好&lt;/label&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; id=&quot;&quot; name=&quot;hobbies&quot; value=&quot;&#123;&#123; student.hobbies &#125;&#125;&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 提取出来的路由模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * router.js 路由模块 * 职责： * 处理路由 * 根据不同的请求方法+请求路径设置具体的请求处理函数 * 模块职责要单一，不要乱写 * 我们划分模块的目的就是为了增强项目代码的可维护性 * 提升开发效率 */var fs = require(&apos;fs&apos;)var Student = require(&apos;./students&apos;)// Express 提供了一种更好的方式// 专门用来包装路由的var express = require(&apos;express&apos;)// 1. 创建一个路由容器var router = express.Router()// 2. 把路由都挂载到 router 路由容器中/* * 渲染学生列表页面 */router.get(&apos;/students&apos;, function(req, res) &#123; Student.find(function(err, students) &#123; if (err) &#123; return res.status(500).send(&apos;Server error.&apos;) &#125; res.render(&apos;index.html&apos;, &#123; students: students &#125;) &#125;)&#125;)/* * 渲染添加学生页面 */router.get(&apos;/students/new&apos;, function(req, res) &#123; res.render(&apos;new.html&apos;)&#125;)/* * 处理添加学生 */router.post(&apos;/students/new&apos;, function(req, res) &#123; // 1. 获取表单数据 // 2. 处理 // 将数据保存到 db.json 文件中用以持久化 // 3. 发送响应 Student.save(req.body, function(err) &#123; if (err) &#123; return res.status(500).send(&apos;Server error.&apos;) &#125; res.redirect(&apos;/students&apos;) &#125;)&#125;)/* * 渲染编辑学生页面 */router.get(&apos;/students/edit&apos;, function(req, res) &#123; // 1. 在客户端的列表页中处理链接问题（需要有 id 参数） // 2. 获取要编辑的学生 id // // 3. 渲染编辑页面 // 根据 id 把学生信息查出来 // 使用模板引擎渲染页面 Student.findById(parseInt(req.query.id), function(err, student) &#123; if (err) &#123; return res.status(500).send(&apos;Server error.&apos;) &#125; res.render(&apos;edit.html&apos;, &#123; student: student &#125;) &#125;)&#125;)/* * 处理编辑学生 */router.post(&apos;/students/edit&apos;, function(req, res) &#123; // 1. 获取表单数据 // req.body // 2. 更新 // Student.updateById() // 3. 发送响应 Student.updateById(req.body, function(err) &#123; if (err) &#123; return res.status(500).send(&apos;Server error.&apos;) &#125; res.redirect(&apos;/students&apos;) &#125;)&#125;)/* * 处理删除学生 */router.get(&apos;/students/delete&apos;, function(req, res) &#123; // 1. 获取要删除的 id // 2. 根据 id 执行删除操作 // 3. 根据操作结果发送响应数据 Student.deleteById(req.query.id, function(err) &#123; if (err) &#123; return res.status(500).send(&apos;Server error.&apos;) &#125; res.redirect(&apos;/students&apos;) &#125;)&#125;)// 3. 把 router 导出module.exports = router 封装的数据操作文件模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 * * 这里才是我们学习 Node 的精华部分：奥义之所在 * 封装异步 API */var fs = require(&apos;fs&apos;)var dbPath = &apos;./db.json&apos;/** * 获取学生列表 * @param &#123;Function&#125; callback 回调函数 */exports.find = function(callback) &#123; fs.readFile(dbPath, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; return callback(err) &#125; callback(null, JSON.parse(data).students) &#125;)&#125;/** * 根据 id 获取学生信息对象 * @param &#123;Number&#125; id 学生 id * @param &#123;Function&#125; callback 回调函数 */exports.findById = function(id, callback) &#123; fs.readFile(dbPath, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students var ret = students.find(function(item) &#123; return item.id === parseInt(id) &#125;) callback(null, ret) &#125;)&#125;/** * 添加保存学生 * @param &#123;Object&#125; student 学生对象 * @param &#123;Function&#125; callback 回调函数 */exports.save = function(student, callback) &#123; fs.readFile(dbPath, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 添加 id ，唯一不重复 student.id = students[students.length - 1].id + 1 // 把用户传递的对象保存到数组中 students.push(student) // 把对象数据转换为字符串 var fileData = JSON.stringify(&#123; students: students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath, fileData, function(err) &#123; if (err) &#123; // 错误就是把错误对象传递给它 return callback(err) &#125; // 成功就没错，所以错误对象是 null callback(null) &#125;) &#125;)&#125;/** * 更新学生 */exports.updateById = function(student, callback) &#123; fs.readFile(dbPath, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 注意：这里记得把 id 统一转换为数字类型 student.id = parseInt(student.id) // 你要修改谁，就需要把谁找出来 // EcmaScript 6 中的一个数组方法：find // 需要接收一个函数作为参数 // 当某个遍历项符合 item.id === student.id 条件的时候，find 会终止遍历，同时返回遍历项 var stu = students.find(function(item) &#123; return item.id === student.id &#125;) // 这种方式你就写死了，有 100 个难道就写 100 次吗？ // stu.name = student.name // stu.age = student.age // 遍历拷贝对象 for (var key in student) &#123; stu[key] = student[key] &#125; // 把对象数据转换为字符串 var fileData = JSON.stringify(&#123; students: students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath, fileData, function(err) &#123; if (err) &#123; // 错误就是把错误对象传递给它 return callback(err) &#125; // 成功就没错，所以错误对象是 null callback(null) &#125;) &#125;)&#125;/** * 删除学生 */exports.deleteById = function(id, callback) &#123; fs.readFile(dbPath, &apos;utf8&apos;, function(err, data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // findIndex 方法专门用来根据条件查找元素的下标 var deleteId = students.findIndex(function(item) &#123; return item.id === parseInt(id) &#125;) // 根据下标从数组中删除对应的学生对象 students.splice(deleteId, 1) // 把对象数据转换为字符串 var fileData = JSON.stringify(&#123; students: students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath, fileData, function(err) &#123; if (err) &#123; // 错误就是把错误对象传递给它 return callback(err) &#125; // 成功就没错，所以错误对象是 null callback(null) &#125;) &#125;)&#125; 入口文件 app.js1234567891011121314151617var express = require(&apos;express&apos;)var router = require(&apos;./router&apos;)var bodyParser = require(&apos;body-parser&apos;)var app = express()app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))app.use(&apos;/node_modules/&apos;, express.static(&apos;./node_modules&apos;))app.use(&apos;/public/&apos;, express.static(&apos;./public&apos;))app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json())app.use(router)app.listen(3000, function() &#123; console.log(&apos;running&apos;)&#125;) 数据库文件 db.json123456789101112131415161718192021222324252627&#123; &quot;students&quot;: [&#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;木槿&quot;, &quot;gender&quot;: 0, &quot;age&quot;: &quot;19&quot;, &quot;hobbies&quot;: &quot;读书，学习，敲代码&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;木槿&quot;, &quot;gender&quot;: 0, &quot;age&quot;: 18, &quot;hobbies&quot;: &quot;读书，学习，敲代码&quot; &#125;, &#123; &quot;id&quot;: 5, &quot;name&quot;: &quot;木槿&quot;, &quot;gender&quot;: 0, &quot;age&quot;: 18, &quot;hobbies&quot;: &quot;读书，学习，敲代码&quot; &#125;, &#123; &quot;name&quot;: &quot;莫子谦&quot;, &quot;gender&quot;: &quot;1&quot;, &quot;age&quot;: &quot;19&quot;, &quot;hobbies&quot;: &quot;唱、跳、rap&quot;, &quot;id&quot;: 15 &#125;]&#125; 源代码可以去我的 github 克隆]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Markdown 特殊字符转义]]></title>
    <url>%2F2019%2F09%2F05%2F%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BD%AC%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[前几天在写博客，编译的时候，报了一条错误Template render error: (unknown path) [Line 87, Column 13],寻找了很久的答案，原来是一些特殊字符的转义问题，记录一下，防止以后再踩同样的坑。- —— &amp;#45; 或 &amp;minus; ：减号! —— &amp;#33; ：惊叹号Exclamation mark” —— &amp;#34; 或 &amp;quot; ：双引号Quotation mark# —— &amp;#35; ：井号Number sign$ —— &amp;#36; ：美元标志Dollar sign% —— &amp;#37; ：百分号Percent sign&amp; —— &amp;#38; 或 &amp;amp; ：Ampersand‘ —— &amp;#39; ：单引号Apostrophe( —— &amp;#40; ：小括号左边部分Left parenthesis) —— &amp;#41; ：小括号右边部分Right parenthesis* —— &amp;#42; ：星号Asterisk+ —— &amp;#43; ：加号Plus sign&lt; —— &amp;#60; 或 &amp;lt; ：小于号Less than= —— &amp;#61; ：等于符号Equals sign&gt; —— &amp;#62; 或 &amp;gt; ：大于号Greater than? —— &amp;#63; ：问号Question mark@ —— &amp;#64; ：Commercial at[ —— &amp;#91; ：中括号左边部分Left square bracket\ —— &amp;#92; ：反斜杠Reverse solidus (backslash)] —— &amp;#93; ：中括号右边部分Right square bracket{ —— &amp;#123; ：大括号左边部分Left curly brace| —— &amp;#124; ：竖线Vertical bar} —— &amp;#125; ：大括号右边部分Right curly brace]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>避坑</tag>
        <tag>转义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七天搞定node.js---第三天]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%AD%A6%E4%B9%A0node.js%E7%9A%84%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[自学node.js第三天的笔记。 知识点 模块系统 核心模块 第三方模块 自己写的模块 npm package.json Express 第三方 Web 开发框架 高度封装了 Http 模块 更加专注于业务，而非底层细节 知其所以然 增删改查 使用文件来保存数据库（锻炼异步编码） MongDB （所有方法都封装好了） 在 Node 中使用 art-template 模板引擎 安装 加载 template.render() 客户端渲染和服务端渲染的区别 最少两次请求，发起 ajax 在客户端使用模板引擎渲染 客户端拿到的就是服务端已经渲染好的 处理留言本案例首页数据列表渲染展示 处理留言本案例发表留言功能 路径 设计好的请求路径 $GET 直接或查询字符串数据 Node 中需要自己动手来解析 url.parse() /pinglun?name=jack&amp;message=hello split(‘?’) name=jack&amp;message=hello split(‘&amp;’) name=jack message=hello forEach() name=jack.split(‘=’) 0 key 1 value 掌握如何解析请求路径中的查询字符串 url.parse() 如何在 Node 中实现服务器重定向 header(‘location’) 301 永久重定向 浏览器会记住 a.com b.com a 浏览器不会请求 a 了 直接去跳到 b 了 302 临时重定向 浏览器不记忆 a.com b.com a.com 还会请求 a a 告诉浏览器你往 b Node 中的 Console（REPL）使用 each和forEach art-template 和 jQuery 一毛钱关系都没有 each 是 art-template 的模板语法，专属的 &#123;&#123;each 数组&#125;&#125; &#60;li&#62;&#123;&#123; $value &#125;&#125;&#60;/li&#62; &#123;&#123;/each&#125;&#125;这是 art-template 模板引擎支持的语法，只能在模板字符串中使用 $.each(数组, function) $(‘div’).each(function) 一般用于遍历 jQuery 选择器选择到的伪数组实例对象 forEach 是 EcmaScript 5 中的一个数组遍历函数，是 JavaScript 原生支持的遍历方法 可以遍历任何可以被遍历的成员 jQuery 的 each 方法和 forEach 几乎一致 由于 forEach 是 EcmaScript 5 中的，所以低版本浏览器不支持 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;node_modules/jquery/dist/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // ie8 以下版本不支持,用jquery就能很好解决兼容问题 // ; // [&apos;ssq&apos;, &apos;木槿&apos;, &apos;test&apos;, &apos;666&apos;].forEach(function(item, index) &#123; // console.log(item) // &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ie8 以下版本不支持 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;node_modules/jquery/dist/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 遍历 jquery 元素 $.each([&apos;ssq&apos;, &apos;木槿&apos;, &apos;test&apos;, &apos;666&apos;], function(index, item) &#123; console.log(item) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里还是报错，原因是jQuery版本安装的是最新版本，2以上的版本都不支持最后把jQuery换成了1.11.0版本后就成功兼容了 Node 中的模块系统使用 Node 编写应用程序主要就是在使用 EcmaScript语言 和浏览器不一样，在 Node 中没有 Bom、Dom 核心模块 文件操作的 fs http 服务的 http url 路径操作模块 path 路径处理模块 os 操作系统信息 第三方模块 art-template 必须通过 npm 来下载才可以使用 自己写的模块 自己创建的文件 什么是模块化 文件作用域 通信规则 加载 require 导出 CommonJS 模块规范在 Node 中的 JavaScript 还有一个很重要的概念：模块系统。 模块作用域 使用 require 方法用来加载模块 使用 exports 接口对象用来导出模块中的成员 加载require123456789// 默认得到的是对象// 使用对象中的成员必须 . 点某个成员来访问// 有时候，对于一个模块,仅仅就想导出一个方法var fooExports = require(&apos;./foo&apos;)// ReferenceError:foo is not defined// console.log(foo)console.log(fooExports) 语法：1var 自定义变量名称 = require(&apos;模块&apos;) 两个作用： 执行被加载模块中的代码 得到被加载模块中的exports导出对象 导出exports12345678910111213141516171819202122232425262728var foo = &apos;bar&apos;function add(x, y) &#123; return x + y&#125;// exports = add //打印出空对象，不行// 如果一个模块需要直接导出某个成员，而非挂载的方式// 那这个时候必须使用下面这种方式module.exports = add// 你可以认为在每个模块的最好 return 了这个 exports// 只能到我想要给你的成员// 这样做的目的是为了解决变量命名冲突的问题// exports.add = add// exports 是一个对象// 可以通过多次为这个对象添加成员实现对外导出多个内部成员// exports.str = &apos;hello&apos;// 若希望加载得到直接就是一个：// 方法// 字符串// 数字// 数组 Node 中是模块作用域，默认文件中所有的成员只在当前文件模块有效 对于希望可以被其他模块访问的成员，我们就需要把这些公开的成员都挂载到exports接口对象中就可以了 导出多个成员（必须在对象中）：12345678exports.a = 123exports.b = &apos;hello&apos;exports.c = function()&#123; console.log(&apos;ccc&apos;)&#125;exports.d = &#123; foo:&apos;bar&apos;&#125; 导出单个成员（拿到的就是：函数、字符串）：1module.exports = &apos;hello&apos; 以下情况会覆盖：123456module.exports = &apos;hello&apos;// 输出的是这条函数，后者会覆盖前者。module.exports = function(x , y)&#123; return x + y&#125; 也可以这样来导出多个成员:123456module.exports = &#123; add:function()&#123; return x + y &#125;, str: &apos;hello&apos;&#125; 原理解析exports 和 module.exports的一个引用： 123456console.log(exports === module.exports)// =&gt; trueexports.foo = &apos;bar&apos;//等价于module.exports.foo = &apos;bar&apos; require 方法加载规则 核心模块 模块名 第三方模块 模块名 用户自己写的模块 路径 优先从缓存加载 判断模块标识 核心模块 第三方模块 自己写的模块 npm 全称：node package manager npm 网站https://www.npmjs.com npm 命令行工具npm 的第二层含义就是一个命令行工具，只要你安装了 node 就已经安装了 npmnpm 也有版本这个概念可以通过在命令行中输入npm --version查看版本号升级npm：1npm install --global npm 常用命令 npm init npm init -y 跳过向导，快速生成 pockage.json npm install 根据 package.json 中的 dependencies 生成 node_modules 简写 npm i npm install 包名 只下载包 简写 npm i 包名 npm install 包名 –save 下载并且保存依赖项(package.json 文件中的 dependencies 选项) 简写 npm i 包名 -S npm uninstall 包名 只删除，如果有依赖项会依然保存 简写 npm un 包名 npm uninstall –save 包名 删除包的同时也会把依赖信息也去除 简写 npm un -S 包名 npm help 查看使用帮助 npm 命令 –help 查看指定命令的使用帮助 解决 npm 被墙问题npm 存储包的服务器在国外，有时候会被墙，速度很慢。http://npm.taobao.org/ 淘宝的开发团队把 npm 在国内做了一个备份。安装淘宝镜像 cnpm：123// 在任意目录执行都可以// --global 表示安装到全局，而非当前目录npm install --global cnpm 接下来你安装包的时候把之前的 npm 替换成 cnpm。举个例子：12345// 这里还是走国外的 npm 服务器，速度比较慢npm install jquery// 使用 cnpm 就会通过淘宝的服务器来下载 jquerycnpm install jquery 如果不想安装 cnpm 又想使用淘宝的服务器来下载：1npm install jquery --registry=https://registry.npm.taobao.org 但是每一次手动这样加参数很麻烦，所以我们可以把这个选项加入配置文件中：1234npm config set registry https://registry.npm.taobao.org// 查看 npm 配置信息npm config list 只要经过了上面命令的配置，则你以后所有的 npm install 都会默认通过淘宝的服务器来下载。 package.json建议每一个项目都要有一个package.json这个文件可以通过 npm init 的方式来自动初始化。 在初始化会以向导的方式询问： 12345678name:项目名字version：项目版本号description：项目描述git repository：github仓库地址keywords：关键词，别人通过npm下载你的项目时main：项目入口文件author：项目作者license：开源协议 对于目前来讲，最重要的是 dependencies 选项，这个可以用来保存第三方包的依赖信息。如果的你的 node_modules 文件丢失了，也不用担心,只需要： npm install 就会自动把 package.json 中的 dependencies 中的所有的依赖项都下载回来。 建议每个根目录下都有一个 package.json 文件； 建议执行 npm install 包名 的时候都加上 --save这个选项，目的是用来保存依赖信息。 Express原生的 http 在某些方面表现不足以应对我们的开发需求,所以我们就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码更高度统一。 在 Node 中，有很多 Web 开发框架，这里以 express 为主。 官网：http://expressjs.com/ Express 的整体感知：123456789101112131415161718192021222324252627282930//0.安装//1.引包var express = require(&apos;express&apos;)//2.创建你服务器应用程序// 也就是原来的 http.createServervar app = express()//在 Express 中开放资源就是一个 API 的事// 公开指定的目录app.use(&apos;/public/&apos;, express.static(&apos;./public/&apos;))app.use(&apos;/static/&apos;, express.static(&apos;./static/&apos;)) // 当服务器收到 get 请求 / 的时候，执行回调函数app.get(&apos;/&apos;, function(req, res) &#123; res.send(&apos;hello express!&apos;)&#125;)app.get(&apos;/about&apos;, function(req, res) &#123; res.send(&apos;about~你好！&apos;) &#125;) // 以前： // 得到路径 // 一个一个判断 // 显得非常不优雅// 相当于 server.listen app.listen(3000, function() &#123; console.log(&apos;app is running at port 3000。&apos;)&#125;) MongoDB总结 jQuery 的 each 和 原生的 JavaScript 方法 forEach EcmaScript 5 提供的 不兼容 IE 8 jQuery 的 each 由 jQuery 这个第三方库提供 jQuery 2 以下的版本是兼容 IE 8 的 它的 each 方法主要用来遍历 jQuery 实例对象（伪数组） 同时它也可以作为低版本浏览器中 forEach 替代品 jQuery 的实例对象不能使用 forEach 方法，如果想要使用必须转为数组才可以使用 [].slice.call(jQuery实例对象) 模块中导出多个成员和导出单个成员 301 和 302 状态码区别 301 永久重定向，浏览器会记住 302 临时重定向 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 trues 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 可以更灵活的去用它 Node 是一个比肩 Java、PHP 的一个平台 JavaScript 既能写前端也能写服务端 12345678moudle.exports = &#123; a: 123&#125;// 重新建立 exports 和 module.exports 之间的引用关系exports = module.exportsexports.foo = &apos;bar&apos; 12345678910111213141516171819202122232425262728Array.prototype.mySlice = function () &#123; var start = 0 var end = this.length if (arguments.length === 1) &#123; start = arguments[0] &#125; else if (arguments.length === 2) &#123; start = arguments[0] end = arguments[1] &#125; var tmp = [] for (var i = start; i &lt; end; i++) &#123; // fakeArr[0] // fakeArr[1] // fakeArr[2] tmp.push(this[i]) &#125; return tmp&#125;var fakeArr = &#123; 0: &apos;abc&apos;, 1: &apos;efg&apos;, 2: &apos;haha&apos;, length: 3&#125;// 所以你就得到了真正的数组。 [].mySlice.call(fakeArr) module.exports 和 exports 的区别 require 方法加载规则 优先从缓存加载 核心模块 路径形式的模块 第三方模块 node_modules package.json 包描述文件 dependencies 选项的作用 npm 常用命令 Express 基本使用 使用 Express 把之前的留言本案例改造一下 index.html页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;留言本&lt;/title&gt; &lt;!-- 浏览器收到 HTML 响应内容之后，就要开始从上到下依次解析， 当在解析的过程中，如果发现： link script img iframe video audio 等带有 src 或者 href（link） 属性标签（具有外链的资源）的时候，浏览器会自动对这些资源发起新的请求。 --&gt; &lt;!-- 注意：在服务端中，文件中的路径就不要去写相对路径了。 因为这个时候所有的资源都是通过 url 标识来获取的 我的服务器开放了 /public/ 目录 所以这里的请求路径都写成：/public/xxx / 在这里就是 url 根路径的意思。 浏览器在真正发请求的时候会最终把 http://127.0.0.1:3000 拼上 不要再想文件路径了，把所有的路径都想象成 url 地址 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Example page header &lt;small&gt;Subtext for header&lt;/small&gt;&lt;/h1&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;/post&quot;&gt;发表留言&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;comments container&quot;&gt; &lt;ul class=&quot;list-group&quot;&gt; &#123;&#123;each comments&#125;&#125; &lt;li class=&quot;list-group-item&quot;&gt;&#123;&#123; $value.name &#125;&#125;说：&#123;&#123; $value.message &#125;&#125; &lt;span class=&quot;pull-right&quot;&gt;&#123;&#123; $value.dateTime &#125;&#125;&lt;/span&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; post.html页面12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt; &lt;small&gt;发表评论&lt;/small&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;comments container&quot;&gt; &lt;!-- 以前表单是如何提交的？ 表单中需要提交的表单控件元素必须具有 name 属性 表单提交分为： 1. 默认的提交行为 2. 表单异步提交 action 就是表单提交的地址，说白了就是请求的 url 地址 method 请求方法 get post --&gt; &lt;form action=&quot;/post&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;input_name&quot;&gt;你的大名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; required minlength=&quot;2&quot; maxlength=&quot;10&quot; id=&quot;input_name&quot; name=&quot;name&quot; placeholder=&quot;请写入你的姓名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;textarea_message&quot;&gt;留言内容&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;message&quot; id=&quot;textarea_message&quot; cols=&quot;30&quot; rows=&quot;10&quot; required minlength=&quot;5&quot; maxlength=&quot;20&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;发表&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 404.html页面12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;抱歉! 您访问的页面失联啦...&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; admin页面12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;admin &#123;&#123; title &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 源代码可以去我的 github 克隆]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11个小技巧教你写出高质量的JavaScript代码]]></title>
    <url>%2F2019%2F08%2F14%2F11%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%95%99%E4%BD%A0%E5%86%99%E5%87%BA%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[所谓的高质量的JavaScript代码，其实指的就是可维护性高，可读性高，可拓展性高的代码，不仅开发的过程中写得舒服，而且后期维护也很轻松的代码质量。 我们可以通过下面这11个要点，从细节来把握我们的JavaScript质量。 可维护性高的代码在我们开发过程中，当出现bug的时候，我们立刻去修复，这时候解决代码bug的思路是最清晰的。否则，你去做了别的代码任务或者这个bug出现了一段时间，你再去处理，你就忘了你写的思路是什么了，那这时候去处理这些代码你就需要想两个问题了： 1.花时间去学习和理解这个代码问题 2.花时间了解bug的解决方案 同时，你如果是在企业中做的大型项目，都是团队开发，开发和维护可能都不是同一个人（发现bug和修复bug的都不是作者）。 所以，必须降低大量的理解代码的时间，无论是你自己写的代码，还是团队中其他人的代码。 这关系到整个项目的发展和开发团队每个人的生活幸福啊，毕竟我们应该多花时间去研究更多好的代码想法，而不是时间都浪费在维护遗留代码里面。 所以，可维护性高的代码很重要，一般可维护性高的代码都有以下这些原则： &emsp;&emsp;1.可读性高（例如好的命名，解析性强的注释） &emsp;&emsp;2.一致性强（命名风格，编码风格，代码规范） &emsp;&emsp;3.可预测性（明显看出运行效果） &emsp;&emsp;4.风格统一（看上去就知道是不是同一个人写完的） &emsp;&emsp;5.有记录（有清晰的注释开发记录） 全局变量的问题什么是全局变量的问题，就是在你的javascript程序和网页中的所有代码都共享这些变量，他们都住在同一个命名空间里面（全局作用域），所以当程序在执行过程中两个不同部分定义同名但不同作用的全局变量的时候，命名冲突的情况就很常见了（许多小白遇到了就抓不着头脑了：咦，这个命名没问题啊，为什么报错了？）。 而且，网页里面包含有其他不是开发作者写的代码而产生的全局命名问题也是比较常见的。比如说： 1.第三方javascript库 2.甲方（或开发团队自己封装的代码）的脚步代码 3.第三方用户跟踪或分析代码 4.不同类型的UI组件 ….. 这些带来的情况就很常见了，比如说，第三方脚本定义了一个变量，叫做userId，接着，你的函数里面也写了个userId的全局变量。这个时候的结果就是，后面的覆盖掉前面的变量，第三方脚本直接就无效了，这种情况是很难调试出来的。 所以，尽可能的少使用全局变量很重要，例如命名空间模式或者函数立即执行，不过要想让全局变量减少，最重要的还是多用var来声明变量。 忘记var的副作用隐式全局变量和显式定义的全局变量是有点差异的。 具体如下： 通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。 没有通过var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。 所以隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。 属性是可以通过delete操作符删除的，而变量是不能的，具体的代码我这里就不说了。 访问全局对象在浏览器中，全局对象可以通过window属性在代码任何地方访问（除非说你做了一些很超乎想象的事情，比如说声明了一个名为window的局部变量）。 但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。 如果你需要在没有硬编码的window标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：123var global = (function ()&#123; return this;&#125;()); for循环在使用for循环的时候，可以遍历拿到数组或者数组类似对象的值，比如说arguments和HTMLCollection对象，一般我们的写法都是这样的：123456// 一般的循环var myArray = [1,2,13,1,3];for (var i = 0; i &lt; myArray.length; i++)&#123; myArray[i] //遍历myArray[i]任意一个下标进行操作&#125; 这种循环的方式并不是很好，每次执行循环的时候都需要获取一次数组的长度，这个时候我们代码的执行效率就特别低了，特别是当myArray不是数组的时候，而是一个HTMLCollection对象的时候。 不扩展内置原型扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。 增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。 使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。 另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。 避免隐式类型转换JavaScript的变量在比较的时候会隐式类型转换。 这就是为什么一些诸如：false == 0 或 “ ” == 0 返回的结果是true。 为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。12345678910111213var zero = 0;if (zero === false) &#123;// 不执行，因为zero为0，而不是false&#125;// 反面示例if (zero == false)&#123;// 执行了~&#125; 编码规范建立和遵循编码规范是很重要的，这让你的代码保持一致性，一目了然，更易于阅读和理解。 一个新的开发者加入这个团队可以通读规范，能马上理解其它团队成员书写的代码，更快上手进行开发。 缩进代码开发，标准的缩进是最基本的，没有缩进的代码基本就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。 注释注释这个，其实是应该只要是写了代码，都要有注释的，让别人一看你的代码就能快速理解你的代码。 在平时我们开发的时候，你很花时间去研究一个程序怎么实现，你会很清楚的知道这个代码是干嘛用的。但是，你一周之后回来再看这段代码，你就会烧掉很多脑细胞了。 当然，注释也不能走极端路线：有的人就说不是要理解没一段代码吗，那每个单独变量或是单独一行就给一段注释。这样就很没有意义了。 一般来说，注释都是记录在函数的部分，它们的参数和返回值，或是一些不寻常的技术和方法。通过注释可以给你代码的未来阅读者以诸多提示； 阅读你代码的人需要的是（不要读太多的东西）注释和函数名来理解你的代码意义。 花括号 { }花括号（也称大括号，下同）应该多使用，即使在它们为可选的时候。技术上来说，在in或是for中如果执行语句仅一条时，花括号是不需要写也能执行理想效果的，但是你最好还是用花括号，因为这会让你的代码更有持续性和易于更新，并且更加好理解。 记住这11个要点，时刻落实到你的代码书写习惯当中，慢慢的，你也能轻松写出大神的代码了。 * 声明：内容与图片均来源于网络（部分内容有修改），版权归原作者所有，如来源信息有误或侵犯权益，请联系我们删除或授权事宜。]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>高质量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5个要矫正的JavaScript编程陋习]]></title>
    <url>%2F2019%2F08%2F13%2F5%E4%B8%AA%E8%A6%81%E7%9F%AB%E6%AD%A3%E7%9A%84JavaScript%E7%BC%96%E7%A8%8B%E9%99%8B%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[在阅读JavaScript（JS）代码时，您是否有过这样的感觉：你几乎完全不明白这条代码的作用？这些代码使用了大量的JS技巧？命名和编程风格相当随意？这些是编程陋习的征兆。 在这篇文章中，我将会概述JS中5种常见的编程陋习。重要的是，我将提出我认为的，关于如何矫正这些陋习的可行的建议。 不要使用隐式类型转换JavaScript是一种松散类型的程序语言。如果使用得当，这对我们是有利的，因为它提供了很大的灵活性。 大多数操作符+ - * / ==(但不是指===)在处理不同类型的操作数时会进行隐式转换。语句if (condition) {…},(while(condition) {…}隐式地将条件转换为布尔值。 下面的示例依赖于类型的隐式转换。我猜你一定感很到困惑:1234567console.log(&quot;2&quot; + &quot;1&quot;); // =&gt; &quot;21&quot;console.log(&quot;2&quot; - &quot;1&quot;); // =&gt; 1console.log(&apos;&apos; == 0); // =&gt; trueconsole.log(true == []); // -&gt; falseconsole.log(true == ![]); // -&gt; false 过分依赖于隐式类型转换是一个陋习.首先，它使你的代码在边缘情况下不够稳定。其次，增加了出现难以重现和修复的bug的机率。 现在咱们使用一个获取对象属性的函数。如果属性不存在，函数返回一个默认值：1234567891011121314function getProp(object, propertyName, defaultValue) &#123; if (!object[propertyName]) &#123; return defaultValue; &#125; return object[propertyName];&#125;const hero = &#123; name: &apos;Batman&apos;, isVillian: false&#125;;console.log(getProp(hero, &apos;name&apos;, &apos;Unknown&apos;)); // =&gt; &apos;Batman&apos; getProp() 读取name属性的值，即为’Batman’。 那么如果我们试图访问isVillian属性呢： console.log(getProp(hero, ‘isVillian’, true)); // =&gt; true 这是一个错误。即使hero的属性isVillian 为false，函数getProp()也会错误得返回true。 这是因为属性存在的验证依赖于if (!object[propertyName]) {…}隐式转换的布尔值。 这些错误很难发现，要修正该函数，就要明确验证值的类型：1234567891011121314function getPropFixed(object, propertyName, defaultValue) &#123; if (object[propertyName] === undefined) &#123; return defaultValue; &#125; return object[propertyName];&#125;const hero = &#123; name: &apos;Batman&apos;, isVillian: false&#125;;console.log(getPropFixed(hero, &apos;isVillian&apos;, true)); // =&gt; false object[propertyName] === undefined确切地验证了属性是否为undefined。 你们有什么其他方法来验证对象中的属性是否存在吗？如果有，请在下面的评论区留言！ 边注：在第4（此处需要一个超链接直接跳到第4部分）部分我有建议避免直接使用undefined。因此，上述解决方案可以用运算符in进一步改进：1234567function getPropFixedBetter(object, propertyName, defaultValue) &#123; if (!(propertyName in object)) &#123; return defaultValue; &#125; return object[propertyName];&#125; 我的建议是:尽可能不要使用隐式类型转换。相反，请确保变量和函数参数始终具有相同的类型，必要时使用显式类型转换。 大家最好这么做： 始终使用严格的相等运算符===进行比较 不要使用松散等式运算符== 加法运算符operand1 + operand2：两个操作数应该是数字或字符串 算术运算符- * / % **：两个操作数都应该是数字 if (condition) {…}，while (condition) {…}等语句中的condition必须是一个布尔类型值 大家可能会觉得这种方式需要编写更多代码…的确！但是通过明确的方法，我们能够控制代码的行为。此外，显性类型转换增强了可读性。 不要使用早期的JavaScript技巧JS的有趣之处在于，它的创建者并没有料到这种语言会如此流行。基于JS构建的应用程序的复杂性比语言发展的速度还要快。这种情况迫使开发人员使用JS技巧和变通方法，只是为了让事情正常运行。 一个典型的例子是查看数组是否包含某个元素。我从不会使用array.indexOf(item) !== -1来检查。 ECMAScript 2015及以后版本的功能要强大得多，可以使用新的语言特性安全地重构许多技巧。在新的ES2015中可以使用array.includes(item)来代替array.indexOf(item) !== -1。大家可以根据我写的重构列表来清除你的JS代码中的老旧技巧。 不要污染函数作用域在ES2015之前，JS变量在函数作用域内，因此大家可能会习惯了将所有变量声明在函数作用域里面。 我们来看一个例子：123456789101112function someFunc(array) &#123; var index, item, length = array.length; /* * Lots of code */ for (index = 0; index &lt; length; index++) &#123; item = array[index]; // Use `item` &#125; return someResult;&#125; 变量index，item和length在函数作用域内。但是这些变量会影响函数作用域，因为它们只在for()块作用域内才被需要。 因为已经引入了具有块作用域let和const，我们应该尽可能地限制变量的生命周期。 让我们来清理一下函数作用域：123456789101112function someFunc(array) &#123; /* * Lots of code */ const length = array.length; for (let index = 0; index &lt; length; index++) &#123; const item = array[index]; // Use `item` &#125; return someResult;&#125; 变量index和item被限制为for()循环块作用域。length被挪到使用地方的附近。 重构后的代码更容易理解，因为变量不会分散在整个函数作用域内，它们存在于使用地方的附近。 在使用的块作用域定义变量： if块作用域1234567// Badlet message;// ...if (notFound) &#123; message = &apos;Item not found&apos;; // Use `message`&#125; 123456// Goodif (notFound) &#123; const message = &apos;Item not found&apos;; // Use `message`&#125; for块作用域123456// Badlet item;for (item of array) &#123; // Use `item`&#125; 12345// Goodfor (const item of array) &#123; // Use `item`&#125; 尽量避免undefined和null未赋值的变量默认被赋值为undefined。例如:12345678let count;console.log(count); // =&gt; undefinedconst hero = &#123; name: &apos;Batman&apos;&#125;;console.log(hero.city); // =&gt; undefined count变量已定义，但尚未使用值初始化。JS隐式赋值给它undefined。 在我们访问不存在的属性hero.city时，也会返回undefined。 为什么直接使用undefined是一个陋习呢？因为与undefined进行比较时，实际上我们正在处理的是未初始化状态的变量。 变量、对象属性和数组在使用前必须用值初始化 JS提供了很多避免与undefined进行比较的方式。 判断属性是否存在1234567// Badconst object = &#123; prop: &apos;value&apos;&#125;;if (object.nonExistingProp === undefined) &#123; // ...&#125; 12345678// Goodconst object = &#123; prop: &apos;value&apos;&#125;;if (&apos;nonExistingProp&apos; in object) &#123; // ...&#125; 对象的默认属性1234567// Badfunction foo(options) &#123; if (object.optionalProp1 === undefined) &#123; object.optionalProp1 = &apos;Default value 1&apos;; &#125; // ...&#125; 123456789101112// Goodfunction foo(options) &#123; const defaultProps = &#123; optionalProp1: &apos;Default value 1&apos; &#125;; options = &#123; ...defaultProps, ...options &#125;; // ...&#125; 默认函数参数1234567// Badfunction foo(param1, param2) &#123; if (param2 === undefined) &#123; param2 = &apos;Some default value&apos;; &#125; // ...&#125; 1234// Goodfunction foo(param1, param2 = &apos;Some default value&apos;) &#123; // ...&#125; null是一个缺失对象的指示符。我们应该尽量避免从函数返回null，特别是使用null作为参数调用函数。 一旦null出现在调用堆栈中，我们就必须在每个可能访问null的函数中检查它的存在，这样我们一不小心就出错了。1234567891011121314151617function bar(something) &#123; if (something) &#123; return foo(&#123; value: &apos;Some value&apos; &#125;); &#125; else &#123; return foo(null); &#125;&#125;function foo(options) &#123; let value = null; if (options !== null) &#123; value = options.value; // ... &#125; return value;&#125; 大家尽量编写不涉及null的代码。可以用try /catch机制替代，默认对象的使用。Algol的发明者Tony Hoare曾说过：“我把它称为我的十几亿美元的错误…[…]我设计了第一个面向对象语言的综合类型系统。[…]但是我无法抗拒放入null引用的诱惑，因为它很容易实现。这导致了无数的错误、漏洞和系统崩溃，在过去四十年中，这些错误和崩溃可能造成了十亿美元的损失。” “计算机科学中最糟糕的错误”一文深入分析了为什么null会破坏代码的质量。 不要使用随意的编码风格，执行一个标准有什么比阅读具有随机编码风格的代码更令人生畏的事情？你永远不知道会发生什么！如果代码库包含许多开发人员的不同编码风格，该怎么办?，这种就像各色人物涂鸦墙。 整个团队和应用程序代码库都需要相同的编码风格，它提高了代码的可读性。 一些有用的编码风格的例子：爱彼迎 JS 风格指南谷歌 JS 风格指南老实说，我很懒。当我正面临着死线或者在回家前准备提交时，我可能会“忘记”设计代码的样式。 懒惰的我总对自己说：先这样吧，以后再更新它，但是”以后”意味着永远不会。 所以在这里我建议使用 eslint 来规范编码风格。安装eslint使用最适合自己的编码风格去配置eslint设置一个预提交hook，在提交之前运行eslint验证。 总结编写高质量和干净的代码需要有纪律性，我们克服编码陋习。 JS是一种自由的编程语言，具有很大的灵活性。但是我们必须注意我们所使用的特性。这里我的建议是避免使用隐式类型转换undefined和null。 现在这种编程语言发展得相当快。找出复杂的代码，并使用最新的JS特性来重构简化。整个代码库的一致编码风格有益于可读性。优秀的编程技能总是一个双赢的解决方案。 今天的分享就到这里，希望本文能帮助到您！ 来源：https://juejin.im/post/5d4add0ce51d45620d2cb89f声明：著作权归作者所有。如有侵权请联系博主删除！！！]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端中关于字符串的操作整理]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%89%8D%E7%AB%AF---%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[为了以后的程序员之路可以走的更远，总结一下关于字符串的一些操作。 charAt()返回在指定位置的字符。123var str=&quot;abc&quot;console.log(str.charAt(0))//a charCodeAt()返回在指定的位置的字符的 Unicode 编码。123var str=&quot;abc&quot; console.log(str.charCodeAt(1)) //98 concat()连接字符串。12345var a = &quot;abc&quot;; var b = &quot;def&quot;; var c = a.concat(b);console.log(c);//abcdef indexOf()检索字符串。indexOf() 方法对大小写敏感！如果要检索的字符串值没有出现，则该方法返回 -1。1234var str=&quot;Hello world!&quot;console.log(str.indexOf(&quot;Hello&quot;))//0console.log(str.indexOf(&quot;World&quot;))//-1console.log(str.indexOf(&quot;world&quot;))///6 match()match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。12var str=&quot;1 abc 2 def 3&quot;console.log(str.match(/\d+/g))//123 replace()replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。12var str=&quot;abc Def!&quot;console.log(str.replace(/abc/, &quot;CBA&quot;))//CBA Def! search()search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。要执行忽略大小写的检索，请追加标志 i。如果没有找到任何匹配的子串，则返回 -1。12var str=&quot;abc DEF!&quot;console.log(str.search(/DEF/))//4 slice()提取字符串的片断，并在新的字符串中返回被提取的部分。stringObject.slice(start,end);start: 要抽取的片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。end：紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。12var str=&quot;abc def ghk&quot;console.log(str.slice(6))//f ghk #split()把字符串分割为字符串数组。1234var str=&quot;abc def ghi jkl&quot; console.log(str.split(&quot; &quot;))//[&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;]console.log(str.split(&quot;&quot;) )//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot; &quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot; &quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot; &quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;]console.log(str.split(&quot; &quot;,3))//[&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;] toLocaleLowerCase()把字符串转换为小写。12var str=&quot;ABC def!&quot;console.log(str.toLocaleLowerCase())//abc def! toLocaleUpperCase()把字符串转换为大写。12var str=&quot;ABC def!&quot;console.log(str.toLocaleUpperCase())//ABC DEF! toLowerCase()把字符串转换为小写。12var str=&quot;ABC def!&quot;console.log(str.toLowerCase())//abc def! toUpperCase()把字符串转换为大写。12var str=&quot;ABC def!&quot;console.log(str.toUpperCase())//ABC DEF! ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。其中，toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语言)会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。一般来说，在不知道自己的代码将在那种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。 substr()从起始索引号提取字符串中指定数目的字符。stringObject.substr(start,length)。start：必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。123var str=&quot;abc def&quot;console.log(str.substr(2))//c defconsole.log(str.substr(2,4))// c de substring()提取字符串中两个指定的索引号之间的字符。stringObject.substring(start,stop)。start ：必需。一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。stop ：可选。一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。123var str=&quot;abc def&quot;console.log(str.substring(2))//c defconsole.log(str.substring(2,4))// c 相同点：如果只是写一个参数，两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。substr(startIndex);substring(startIndex);123var str = &apos;123456789&apos;;console.log(str.substr(2)); // &quot;3456789&quot;console.log(str.substring(2)) ;// &quot;3456789&quot; 不同点：第二个参数substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）；substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’）。12console.log(&quot;123456789&quot;.substr(2,5)); // &quot;34567&quot;console.log(&quot;123456789&quot;.substring(2,5)) ;// &quot;345&quot; ES6新增的操作字符串的方法 codePointAt()1234let s = &apos;𠮷a&apos;;s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。12String.fromCharCode(0x20BB7)// &quot;ஷ&quot; 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。1234String.fromCodePoint(0x20BB7)// &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;// true 字符串的遍历器接口 for of123456for (let codePoint of &apos;abc&apos;) &#123; console.log(codePoint)&#125;// &quot;a&quot;// &quot;b&quot;// &quot;c&quot; 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 at（）at方法可以识别Unicode 编号大于0xFFFF的字符，返回正确的字符。12&apos;abc&apos;.at(0)//&quot;a&quot;&apos;吉&apos;.at(0)//&quot;吉&quot; normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（u004F）和ˇ（u030C）合成Ǒ（u004Fu030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。123&apos;\u01D1&apos;===&apos;\u004F\u030C&apos; //false &apos;\u01D1&apos;.length // 1&apos;\u004F\u030C&apos;.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。12&apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize()// true includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。1234567**includes()**：返回布尔值，表示是否找到了参数字符串。**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。let s = &apos;Hello world!&apos;; s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。1234let s = &apos;Hello world!&apos;; s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5) // trues.includes(&apos;Hello&apos;, 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。123&apos;x&apos;.repeat(3) // &quot;xxx&quot;&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;&apos;na&apos;.repeat(0) // &quot;&quot; 参数如果是小数，会被取整。1&apos;na&apos;.repeat(2.9) // &quot;nana&quot; 如果repeat的参数是负数或者Infinity，会报错。1234&apos;na&apos;.repeat(Infinity)// RangeError&apos;na&apos;.repeat(-1)// RangeError padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。12345&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos; 上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。12&apos;xxx&apos;.padStart(2, &apos;ab&apos;) // &apos;xxx&apos;&apos;xxx&apos;.padEnd(2, &apos;ab&apos;) // &apos;xxx&apos; 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。12&apos;abc&apos;.padStart(10, &apos;0123456789&apos;)// &apos;0123456abc&apos; 如果省略第二个参数，默认使用空格补全长度。12&apos;x&apos;.padStart(4) // &apos; x&apos;&apos;x&apos;.padEnd(4) // &apos;x &apos; padStart的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。123&apos;1&apos;.padStart(10, &apos;0&apos;) // &quot;0000000001&quot;&apos;12&apos;.padStart(10, &apos;0&apos;) // &quot;0000000012&quot;&apos;123456&apos;.padStart(10, &apos;0&apos;) // &quot;0000123456&quot; 另一个用途是提示字符串格式。12&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-MM-12&quot;&apos;09-12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-09-12&quot; matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配。1const matchIterator = str.matchAll(regExp); 给定一个字符串和一个正则表达式，.matchAll（）为所有匹配的匹配对象返回一个迭代器。 字符串模板模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。—–字符串模板，工作中用到比较多。12345678910111213// 普通字符串`In JavaScript &apos;\n&apos; is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。123456$(&apos;#list&apos;).html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如 ul 标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。123456$(&apos;#list&apos;).html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // &apos;User &apos; // + user.name // + &apos; is not authorized to do &apos; // + action // + &apos;.&apos; `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// &quot;1 + 2 = 3&quot;`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// &quot;1 + 4 = 5&quot;let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// &quot;3&quot; 模板字符串之中还能调用函数。12345function fn() &#123; return &quot;Hello World&quot;;&#125; `foo $&#123;fn()&#125; bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。如果模板字符串中的变量没有声明，将报错。123// 变量place没有声明let msg = `Hello, $&#123;place&#125;`;// 报错 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。12`Hello $&#123;&apos;World&apos;&#125;`// &quot;Hello World&quot; 模板字符串甚至还能嵌套。123456789&lt;pre class=&quot;hljs xml&quot;&gt;//code from http://caibaojian.com/js-string.html`const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join(&apos;&apos;)&#125; &lt;/table&gt;`;`&lt;/pre&gt; * 声明：内容与图片均来源于网络（部分内容有修改），版权归原作者所有，如来源信息有误或侵犯权益，请联系我们删除或授权事宜。]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七天搞定node.js---第二天]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%AD%A6%E4%B9%A0node.js%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[这是学习node.js第二天的笔记。 代码风格 无分号 ( [ ` 最好前面补分号，避免一些问题 《编写可维护的 JavaScript》 不仅是功能，还要写的漂亮 服务端渲染 说白了就是在服务端使用模板引擎 模板引擎最早诞生于服务端，后来才发展到了前端 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染 代码风格 JavaScript Standard Style Airbnb JavaScript Style Guide 分号问题12345678910111213141516171819202122232425262728293031function say() &#123; console.log(&apos;hello world&apos;)&#125;//say()方法后面不加分号会报一个错误：TypeError: say(...) is not a functionsay()// ;// (function() &#123;// console.log(&apos;你好，你好&apos;)// &#125;)()// ;// [&apos;苹果&apos;, &apos;香蕉&apos;, &apos;牛奶&apos;].forEach(function(item) &#123;// console.log(item)// &#125;)// ` 是 EcmaScript 6 中新增的一种字符串包裹方式，叫做：模板字符串// 它支持换行和非常方便拼接变量;`hello`.toString()//当你采用了无分号的代码风格的时候，只需要注意以下情况就不会有上面的问题了:// 当一行代码是以：// (// [// `// 开头的时候，则在前面补上一个分号用以避免一些语法解析错误。// 结论：无论你的代码风格是否有分号，都建议如果一行代码是以 ( 、 [ 、 ` 开头的最好都在其前面补上分号;// 也有些代码是花里胡哨的，前面不用分号，而是用 ~ &amp; ！等代替分号。 初步实现Apache(阿帕奇)功能011234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;) // 1.创建 Servervar server = http.createServer() // 2.监听 Server 的 request 请求事件，设置请求处理函数 // 请求 // 处理 // 响应 // 一个请求对应一个响应，如果在一个请求的过程中，已经结束响应了，则不能重复发送响应。 // 没有请求就没有响应。server.on(&apos;request&apos;, function(req, res) &#123; // console.log(req.url) var wwwDir = &apos;../www&apos; var url = req.url if (url === &apos;/&apos;) &#123; fs.readFile(wwwDir + &apos;/index.html&apos;, function(err, data) &#123; // if (err) &#123; // res.end(&apos;404 Not Found.&apos;) // &#125; else&#123; // &#125; if (err) &#123; // return 有两个作用： // 1.方法返回值 // 2.阻止代码继续往后执行 return res.end(&apos;404 Not Found.&apos;) &#125; res.end(data) &#125;) &#125; else if (url === &apos;/test1&apos;) &#123; fs.readFile(wwwDir + &apos;/test1.txt&apos;, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Found.&apos;) &#125; res.end(data) &#125;) &#125; else if (url === &apos;/test2&apos;) &#123; fs.readFile(wwwDir + &apos;/test2.txt&apos;, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Found.&apos;) &#125; res.end(data) &#125;) &#125; else &#123; res.end(&apos;404 Not Found ~~~ .&apos;) &#125; &#125;) // 3.绑定端口号，启动服务server.listen(3000, function() &#123; console.log(&apos;running ~ ~&apos;)&#125;) 初步实现Apache功能021234567891011121314151617181920212223242526272829303132var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;) // 1.创建 Servervar server = http.createServer()var wwwDir = &apos;../www&apos; // 2.监听 Server 的 request 请求事件，设置请求处理函数 // 请求 // 处理 // 响应 // 一个请求对应一个响应，如果在一个请求的过程中，已经结束响应了，则不能重复发送响应。 // 没有请求就没有响应。server.on(&apos;request&apos;, function(req, res) &#123; // console.log(req.url) var url = req.url var filePath = &apos;/index.html&apos; if (url !== &apos;/&apos;) &#123; filePath = url &#125; // console.log(filePath, wwwDir + filePath) fs.readFile(wwwDir + filePath, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Found.&apos;) &#125; res.end(data) &#125;) &#125;) // 3.绑定端口号，启动服务server.listen(3000, function() &#123; console.log(&apos;running ~ ~&apos;)&#125;) Apache完成目录列表渲染12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var server = http.createServer()var wwwDir = &apos;D:/Movie/www&apos;server.on(&apos;request&apos;, function(req, res) &#123; var url = req.url fs.readFile(&apos;./template.html&apos;, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Found.&apos;) &#125; // 1. 如何得到 wwwDir 目录列表中的文件名和目录名 // fs.readdir // 2. 如何将得到的文件名和目录名替换到 template.html 中 // 2.1 在 template.html 中需要替换的位置预留一个特殊的标记（就像以前使用模板引擎的标记一样） // 2.2 根据 files 生成需要的 HTML 内容 // 只要你做了这两件事儿，那这个问题就解决了 fs.readdir(wwwDir, function(err, files) &#123; if (err) &#123; return res.end(&apos;Can not find www dir.&apos;) &#125; // 2.1 生成需要替换的内容 var content = &apos;&apos; files.forEach(function(item) &#123; // 在 EcmaScript 6 的 ` 字符串中，可以使用 $&#123;&#125; 来引用变量 content += ` &lt;tr&gt; &lt;td data-value=&quot;apple/&quot;&gt;&lt;a class=&quot;icon dir&quot; href=&quot;/D:/Movie/www/apple/&quot;&gt;$&#123;item&#125;/&lt;/a&gt;&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;0&quot;&gt;&lt;/td&gt; &lt;td class=&quot;detailsColumn&quot; data-value=&quot;1509589967&quot;&gt;2017/11/2 上午10:32:47&lt;/td&gt; &lt;/tr&gt; ` &#125;) // 2.3 替换 data = data.toString() data = data.replace(&apos;^_^&apos;, content) // 3. 发送解析替换过后的响应数据 res.end(data) &#125;) &#125;)&#125;)server.listen(3000, function() &#123; console.log(&apos;running...&apos;)&#125;) 12345678var fs = require(&apos;fs&apos;)fs.readdir(&apos;D:/Movie/www&apos;, function(err, files) &#123; if (err) &#123; return console.log(&apos;目录不存在&apos;) &#125; console.log(files)&#125;) 在 node 中使用模板引擎模板引擎不关心内容！ 在浏览器中使用模板引擎： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06-在浏览器中使用art-template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 注意：在浏览器中需要引用 lib/template-web.js 文件 强调：模板引擎不关心你的字符串内容，只关心自己能认识的模板标记语法，例如 &#123;&#123;&#125;&#125; &#123;&#123;&#125;&#125; 语法被称之为 mustache 语法，八字胡啊。 --&gt; &lt;script src=&quot;node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/template&quot; id=&quot;tpl&quot;&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;大家好，我叫：&#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p&gt;我今年 &#123;&#123; age &#125;&#125; 岁了&lt;/p&gt; &lt;h1&gt;我来自 &#123;&#123; province &#125;&#125;&lt;/h1&gt; &lt;p&gt;我喜欢：&#123;&#123;each hobbies&#125;&#125; &#123;&#123; $value &#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &lt;/script&gt; &lt;script&gt; var ret = template(&apos;tpl&apos;, &#123; name: &apos;Jack&apos;, age: 18, province: &apos;广东省&apos;, hobbies: [ &apos;写代码&apos;, &apos;唱歌&apos;, &apos;打游戏&apos; ] &#125;) console.log(ret) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在 node 中使用模板引擎: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// art-template// art-template 不仅可以在浏览器使用，也可以在 node 中使用// 安装：// npm install art-template// 该命令在哪执行就会把包下载到哪里。默认会下载到 node_modules 目录中// node_modules 不要改，也不支持改。// 在 Node 中使用 art-template 模板引擎// 模板引起最早就是诞生于服务器领域，后来才发展到了前端。// // 1. 安装 npm install art-template// 2. 在需要使用的文件模块中加载 art-template// 只需要使用 require 方法加载就可以了：require(&apos;art-template&apos;)// 参数中的 art-template 就是你下载的包的名字// 也就是说你 isntall 的名字是什么，则你 require 中的就是什么// 3. 查文档，使用模板引擎的 APIvar template = require(&apos;art-template&apos;)var fs = require(&apos;fs&apos;)// 这里不是浏览器// template(&apos;script 标签 id&apos;, &#123;对象&#125;)// var tplStr = `// &lt;!DOCTYPE html&gt;// &lt;html lang=&quot;en&quot;&gt;// &lt;head&gt;// &lt;meta charset=&quot;UTF-8&quot;&gt;// &lt;title&gt;Document&lt;/title&gt;// &lt;/head&gt;// &lt;body&gt;// &lt;p&gt;大家好，我叫：&#123;&#123; name &#125;&#125;&lt;/p&gt;// &lt;p&gt;我今年 &#123;&#123; age &#125;&#125; 岁了&lt;/p&gt;// &lt;h1&gt;我来自 &#123;&#123; province &#125;&#125;&lt;/h1&gt;// &lt;p&gt;我喜欢：&#123;&#123;each hobbies&#125;&#125; &#123;&#123; $value &#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/p&gt;// &lt;/body&gt;// &lt;/html&gt;// `fs.readFile(&apos;./tpl.html&apos;, function (err, data) &#123; if (err) &#123; return console.log(&apos;读取文件失败了&apos;) &#125; // 默认读取到的 data 是二进制数据 // 而模板引擎的 render 方法需要接收的是字符串 // 所以我们在这里需要把 data 二进制数据转为 字符串 才可以给模板引擎使用 var ret = template.render(data.toString(), &#123; name: &apos;Jack&apos;, age: 18, province: &apos;广东省&apos;, hobbies: [ &apos;写代码&apos;, &apos;唱歌&apos;, &apos;打游戏&apos; ], title: &apos;个人信息&apos; &#125;) console.log(ret)&#125;) 在Apache案例中加入模板引擎1234567891011121314151617181920212223242526272829303132333435363738394041var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var template = require(&apos;art-template&apos;)var server = http.createServer()var wwwDir = &apos;D:/Movie/www&apos;server.on(&apos;request&apos;, function (req, res) &#123; var url = req.url fs.readFile(&apos;./template-apache.html&apos;, function (err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Found.&apos;) &#125; // 1. 如何得到 wwwDir 目录列表中的文件名和目录名 // fs.readdir // 2. 如何将得到的文件名和目录名替换到 template.html 中 // 2.1 在 template.html 中需要替换的位置预留一个特殊的标记（就像以前使用模板引擎的标记一样） // 2.2 根据 files 生成需要的 HTML 内容 // 只要你做了这两件事儿，那这个问题就解决了 fs.readdir(wwwDir, function (err, files) &#123; if (err) &#123; return res.end(&apos;Can not find www dir.&apos;) &#125; // 这里只需要使用模板引擎解析替换 data 中的模板字符串就可以了 // 数据就是 files // 然后去你的 template.html 文件中编写你的模板语法就可以了 var htmlStr = template.render(data.toString(), &#123; title: &apos;哈哈&apos;, files: files &#125;) // 3. 发送解析替换过后的响应数据 res.end(htmlStr) &#125;) &#125;)&#125;)server.listen(3000, function () &#123; console.log(&apos;running...&apos;)&#125;) 服务端渲染与客户端渲染的区别服务端： 客户端： url模块的使用12345var url = require(&apos;url&apos;)var obj = url.parse(&apos;/pinglun?name=sdfs&amp;message=dsfghdghdghd&apos;, true)console.log(obj)console.log(obj.query) 简单的留言功能小案例服务端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// app application 应用程序// 把当前模块所有的依赖项都声明在文件模块最上面// 为了让目录结构保持统一清晰，所以我们约定，把所有的 HTML 文件都放到 views（视图） 目录中// 我们为了方便的统一处理这些静态资源，所以我们约定把所有的静态资源都存放在 public 目录中// 哪些资源能被用户访问，哪些资源不能被用户访问，我现在可以通过代码来进行非常灵活的控制// / index.html// /public 整个 public 目录中的资源都允许被访问// 前后端融会贯通了，为所欲为var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)var template = require(&apos;art-template&apos;)var comments = [&#123; name: &apos;木槿&apos;, message: &apos;今天天气不错！&apos;, dateTime: &apos;2019-08-14&apos; &#125;, &#123; name: &apos;木槿2&apos;, message: &apos;今天天气不错！&apos;, dateTime: &apos;2019-08-14&apos; &#125;, &#123; name: &apos;木槿3&apos;, message: &apos;今天天气不错！&apos;, dateTime: &apos;2019-08-14&apos; &#125;, &#123; name: &apos;木槿4&apos;, message: &apos;今天天气不错！&apos;, dateTime: &apos;2019-08-14&apos; &#125;, &#123; name: &apos;木槿5&apos;, message: &apos;今天天气不错！&apos;, dateTime: &apos;2019-08-14&apos; &#125;]http .createServer(function(req, res) &#123; // 使用 url.parse 方法将路径解析为一个方便操作的对象，第二个参数为 true 表示直接将查询字符串转为一个对象（通过 query 属性来访问） var parseObj = url.parse(req.url, true) // 单独获取不包含查询字符串的路径部分（该路径不包含 ? 之后的内容） var pathname = parseObj.pathname if (pathname === &apos;/&apos;) &#123; fs.readFile(&apos;./views/index.html&apos;, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Founf.&apos;) &#125; var htmlStr = template.render(data.toString(), &#123; comments: comments &#125;) res.end(htmlStr) &#125;) &#125; else if (pathname === &apos;/post&apos;) &#123; fs.readFile(&apos;./views/post.html&apos;, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Found ~&apos;) &#125; res.end(data) &#125;) &#125; else if (pathname.indexOf(&apos;/public/&apos;) === 0) &#123; // /public/css/main.css // /public/js/main.js // /publis/lib/jquery.js // 统一处理 // 如果请求路径是以 /public/开头的，则我认为你获取 public 中的某个资源 // 所以我们就直接可以把请求路径当作文件路径来直接进行读取 fs.readFile(&apos;.&apos; + pathname, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Founf.&apos;) &#125; res.end(data) &#125;) &#125; else if (pathname === &apos;/pinglun&apos;) &#123; // 注意：这个时候无论 /pinglun?xxx 之后是什么，都不用担心了，因为我的 pathname 是不包含 ? 之后的那个路径 // 一次请求对应一次响应，响应结束这次请求也就结束了 // console.log(&apos;收到表单请求了~&apos;, parseObj.query) // res.end(JSON.stringify(parseObj.query)) // 我们已经使用 url 模块的 parse 方法把请求路径中的查询字符串给解析成一个对象了 // 所以接下来要做的就是： // 1. 获取表单提交的数据 parseObj.query // 2. 将当前时间日期添加到数据对象中，然后存储到数组中 // 3. 让用户重定向跳转到首页 / // 当用户重新请求 / 的时候，我数组中的数据已经发生变化了，所以用户看到的页面也就变了 var comment = parseObj.query comment.dateTime = &apos;2019-08-14&apos; comments.unshift(comment) // 服务端这个时候已经把数据存储好了，接下来就是让用户重新请求 / 首页，就可以看到最新的留言内容了 // 如何通过服务器让客户端重定向？ // 1. 状态码设置为 302 临时重定向 // statusCode // 2. 在响应头中通过 Location 告诉客户端往哪儿重定向 // setHeader // 如果客户端发现收到服务器的响应的状态码是 302 就会自动去响应头中找 Location ，然后对该地址发起新的请求 // 所以你就能看到客户端自动跳转了 res.statusCode = 302 res.setHeader(&apos;Location&apos;, &apos;/&apos;) res.end() &#125; else &#123; fs.readFile(&apos;./views/404.html&apos;, function(err, data) &#123; if (err) &#123; return res.end(&apos;404 Not Found ~&apos;) &#125; res.end(data) &#125;) &#125; &#125;) .listen(3000, function() &#123; console.log(&apos;running...&apos;) &#125;) 客户端： 评论列表页面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;留言本&lt;/title&gt; &lt;!-- 浏览器收到 HTML 响应内容之后，就要开始从上到下依次解析， 当在解析的过程中，如果发现： link script img iframe video audio 等带有 src 或者 href（link） 属性标签（具有外链的资源）的时候，浏览器会自动对这些资源发起新的请求。 --&gt; &lt;!-- 注意：在服务端中，文件中的路径就不要去写相对路径了。 因为这个时候所有的资源都是通过 url 标识来获取的 我的服务器开放了 /public/ 目录 所以这里的请求路径都写成：/public/xxx / 在这里就是 url 根路径的意思。 浏览器在真正发请求的时候会最终把 http://127.0.0.1:3000 拼上 不要再想文件路径了，把所有的路径都想象成 url 地址 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;img src=&quot;/public/img/ab3.jpg&quot; alt=&quot;&quot;&gt; --&gt; &lt;div class=&quot;header container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Example page header &lt;small&gt;Subtext for header&lt;/small&gt;&lt;/h1&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;/post&quot;&gt;发表留言&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;comments container&quot;&gt; &lt;ul class=&quot;list-group&quot;&gt; &#123;&#123;each comments&#125;&#125; &lt;li class=&quot;list-group-item&quot;&gt;&#123;&#123; $value.name &#125;&#125;说：&#123;&#123; $value.message &#125;&#125; &lt;span class=&quot;pull-right&quot;&gt;&#123;&#123; $value.dateTime &#125;&#125;&lt;/span&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 发表评论页面：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;发表评论&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/public/lib/bootstrap/dist/css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt; &lt;small&gt;发表评论&lt;/small&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;comments container&quot;&gt; &lt;!-- 以前表单是如何提交的？ 表单中需要提交的表单控件元素必须具有 name 属性 表单提交分为： 1. 默认的提交行为 2. 表单异步提交 action 就是表单提交的地址，说白了就是请求的 url 地址 method 请求方法 get post --&gt; &lt;form action=&quot;/pinglun&quot; method=&quot;get&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;input_name&quot;&gt;你的大名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; required minlength=&quot;2&quot; maxlength=&quot;10&quot; id=&quot;input_name&quot; name=&quot;name&quot; placeholder=&quot;请写入你的姓名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;textarea_message&quot;&gt;留言内容&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;message&quot; id=&quot;textarea_message&quot; cols=&quot;30&quot; rows=&quot;10&quot; required minlength=&quot;5&quot; maxlength=&quot;20&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;发表&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 404 页面：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;抱歉! 您访问的页面失联啦...&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 源代码可以去我的 github 克隆]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CSS实现弹跳动画]]></title>
    <url>%2F2019%2F08%2F03%2FCSS%E5%BC%B9%E8%B7%B3%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[这是只用了一个div来做的小动画，纯粹利用CSS3的animation来完成，就像是一个正方形在地上弹跳，碰到地面的时候尖角还会压缩变圆，阴影的部分也会随着正方形升高而缩小，至于到底该怎么完成呢？让我们继续看下去。 利用伪元素由于只使用了一个div，要同时达到正方形旋转与阴影缩放的效果，这里必须使用两个伪元素（before与after）来完成，严格来说，虽然只有一个div，但是却是把这个div当作外框，让伪元素before作为旋转的正方形，让伪元素after作为阴影。123456789101112131415161718192021222324252627.box&#123; position:relative;&#125;.box:before&#123; content:&apos;&apos;; position:absolute; z-index:2; top:60px; left:50px; width:50px; height:50px; background:#c00; border-radius:2px; transform: rotate(45deg);&#125;.box:after&#123; content:&apos;&apos;; position:absolute; z-index:1; top:128px; left:52px; width:44px; height:3px; background:#eaeaea; border-radius:100%;&#125; CSS动画画出正方形与阴影之后，再来就是要做动画了，为了避免太过复杂，这里我们先不要旋转，先单纯让正方形上下跳动，然后阴影会放大缩小，下面的示例的动画，又新增了20%与80%的keyframe，目的是为了让接触的时候角落才会变圆，不然就会变成刚开始移动时尖角就变圆，就会很怪异了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.box:before&#123; content:&apos;&apos;; position:absolute; z-index:2; top:60px; left:50px; width:50px; height:50px; background:#c00; border-radius:2px; transform: rotate(45deg); -webkit-animation:box .8s infinite ; &#125;@-webkit-keyframes box&#123; 0%&#123; top:50px; &#125; 20%&#123; border-radius:2px; /*从20%的地方才开始变形*/ &#125; 50%&#123; top:80px; border-bottom-right-radius:25px; &#125; 80%&#123; border-radius:2px; /*到80%的地方恢复原状*/ &#125; 100%&#123; top:50px; &#125;&#125;.box:after&#123; content:&apos;&apos;; position:absolute; z-index:1; top:128px; left:52px; width:44px; height:3px; background:#eaeaea; border-radius:100%; -webkit-animation:shadow .8s infinite ; &#125;@-webkit-keyframes shadow&#123; 0%,100%&#123; left:54px; width:40px; background:#eaeaea; &#125; 50%&#123; top:126px; left:50px; /*让阴影保持在原位*/ width:50px; height:7px; background:#eee; &#125;&#125; 加入旋转效果了解原理之后，我们只要再加上旋转的属性，就可以达到弹跳起来的时候有旋转的效果，不过这里又有用到一个小技巧，就是落下的时候是90度转到45度，弹上去的时候从45旋转到0度，然后在这一瞬间从0度变成90度（100%到0%），如此一来我们就会产生错觉，感觉好像一直在旋转了。12345678910111213141516171819202122@-webkit-keyframes box&#123; 0%&#123; top:50px; transform: rotate(-90deg); /**/ &#125; 20%&#123; border-radius:2px; &#125; 50%&#123; top:80px; transform: rotate(45deg); border-bottom-right-radius:25px; &#125; 80%&#123; border-radius:2px; &#125; 100%&#123; top:50px; transform: rotate(0deg); &#125;&#125; 完整项目代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;css3弹跳动画&lt;/title&gt; &lt;style&gt; .box &#123; position: relative; &#125; /* 简单画出大概 */ /* .box:before &#123; content: &apos;&apos;; position: absolute; z-index: 2; top: 60px; left: 50px; width: 50px; height: 50px; background: #c00; border-radius: 2px; transform: rotate(45deg); &#125; .box:after &#123; content: &apos;&apos;; position: absolute; z-index: 1; top: 128px; left: 52px; width: 44px; height: 3px; background: #eaeaea; border-radius: 100%; &#125; */ /* 跳动 */ .box:before &#123; content: &apos;&apos;; position: absolute; z-index: 2; top: 60px; left: 50px; width: 50px; height: 50px; background: #c00; border-radius: 2px; transform: rotate(45deg); -webkit-animation: box .8s infinite; &#125; @-webkit-keyframes box &#123; 0% &#123; top: 50px; &#125; 20% &#123; border-radius: 2px; /*从20%的地方才开始变形*/ &#125; 50% &#123; top: 80px; border-bottom-right-radius: 25px; &#125; 80% &#123; border-radius: 2px; /*到80%的地方恢复原状*/ &#125; 100% &#123; top: 50px; &#125; &#125; .box:after &#123; content: &apos;&apos;; position: absolute; z-index: 1; top: 128px; left: 52px; width: 44px; height: 3px; background: #eaeaea; border-radius: 100%; -webkit-animation: shadow .8s infinite; &#125; @-webkit-keyframes shadow &#123; 0%, 100% &#123; left: 54px; width: 40px; background: #eaeaea; &#125; 50% &#123; top: 126px; left: 50px; /*让阴影保持在原位*/ width: 50px; height: 7px; background: #eee; &#125; &#125; /* 加入旋转 */ @-webkit-keyframes box &#123; 0% &#123; top: 50px; transform: rotate(-90deg); /**/ &#125; 20% &#123; border-radius: 2px; &#125; 50% &#123; top: 80px; transform: rotate(45deg); border-bottom-right-radius: 25px; &#125; 80% &#123; border-radius: 2px; &#125; 100% &#123; top: 50px; transform: rotate(0deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
        <category>进阶</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12个令人惊叹的 CSS 项目]]></title>
    <url>%2F2019%2F08%2F02%2F12%E4%B8%AA%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%20CSS%20%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[或许，你认为 CSS 只能用来控制网页的结构与样式，但它的功能和应用却超乎你的想象。从逼真的图像到特效动画，优秀的开发者利用它已创造了无数种可能。在本文中，我们精选了纯 CSS 实现的滤镜以及各种效果，与大家分享。它们都是开源的网页设计相关项目。除了体验之外，有兴趣的话，你还可以尝试来实现它们。 1.Solar System如果你对太空场景情有独钟，那么一定会被这个 CSS 实现的太阳系动画所震撼。作为空间学与物理学爱好者，作者参照了太阳系轨道运行的真实时间进行设计，意味着每个行星都有相对地球年的时间，准确的围绕太阳公转。 项目地址：https://codepen.io/kowlor/pen/ZYYQoy 2.Gradient Background Animation对于网站性能来说，动画是众人皆知的问题引发者。如果优化不佳，它们会直接影响页面的打开速度。而这个 CSS 实现的漂亮的渐变动画，却相当的轻量，不仅易于编辑，而且支持自定义颜色。 项目地址：https://codepen.io/P1N2O/pen/pyBNzX 3.Stack Game实现一款简单的游戏，并不一定需要 JS 的帮助，纯 CSS 也能够创造一款界面漂亮的 Stack 游戏。当然，游戏看似容易，背后的设计并非那么简单。 项目地址：https://codepen.io/finnhvman/pen/xJRMJp 4.3D Progress Bars这是一款漂亮、轻量、易于定制的进度条开源项目。进度条采用 3D 制作，同时拥有清澈的外观，你甚至可以将它们变成迷你 3D 图表！ 项目地址：https://codepen.io/rgg/pen/QbRyOq 5.Glitched Text故障风格的文本总会让人有眼前一亮的感觉，而这个项目就是纯 CSS 实现的故障效果。如果你想为网站增添酷炫的故障效果，那么不妨多了解下。 项目地址：https://codepen.io/lbebber/pen/ypgql 6.FrancineCSS 的能量超乎你想象，你甚至还可以利用它制作出艺术品效果。Francine 就是一个纯 CSS 制作、展示的 18 世纪风格的绘画作品。或许，你会惊讶 CSS 实现的效果竟能如此逼真。 项目地址：https://github.com/cyanharlow/purecss-francine 7.Mobile Phone这个项目与《Francine》有异曲同工之处，它仅使用 CSS 和 HTML 便实现了手机界面效果，而且效果可以同网站照片相媲美。如果你有兴趣，可详细的了解其实现的过程。 项目地址：https://codepen.io/Wujek_Greg/pen/LmrweG 8.Map Creator利用 JS 创造一个简单的 3D 地图？不用那么复杂，纯 CSS 就可以搞定。怎么样，看上去还不错吧！ 项目地址：https://codepen.io/onediv/pen/NrNebj 9.Instagram.css想为你的网站添加一些 Instagram 风格的图片滤镜效果？那么，纯 CSS 实现的 InstagInstagram.cssram 风格的滤镜库 —— Instagram.css 一定是你的菜。它的灵感来源于 CSSgram. 项目地址：https://picturepan2.github.io/instagram.css/ 10.Animated Gradient Ghost Button这是一个纯 CSS 实现的渐变幽灵按钮。漂亮的动画和渐变效果，是不是很酷呢？相信，它可以很好的融入到任何网站之中。 项目地址：https://codepen.io/ARS/pen/vEwEPP 11.Devices.css如果你想在网站增添 iPhone X、iPhone 8 等移动设备用于展示的话，那么一定不要错过 Devices.css. 它是一个使用了纯 CSS 实现主流移动设备的库，并以现代设备为模版。 项目地址：https://picturepan2.github.io/devices.css/ 12.Dynamic Image Colorizing这是一个很酷的纯 CSS 实现的项目。你只需要通过电脑自带的选色器，就能轻松地更换图像的颜色，来试试吧！ 项目地址：https://codepen.io/noahblon/pen/ZbjmbK 最后利用 JS，我们能实现各种让人惊叹的页面/动画效果，但 JS 并不是最轻量的解决方案。如果合理使用 CSS，你依然可以实现一些炫酷的效果，并且它对性能的影响会小得多。当然，无论你使用哪种方式（JS or CSS），你都可以创造出创意且有趣的作品。 注：本文版权归原作者所有，仅用于学习与交流；如需转载，烦请按下方注明出处信息，谢谢！英文原文：12 Incredible Pure CSS Experiments 里面还有很多有趣的项目作者：Brenda Stokes Barron搬运：莫子谦]]></content>
      <categories>
        <category>css</category>
        <category>进阶</category>
        <category>技术</category>
        <category>壮观</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>特效</tag>
        <tag>值得欣赏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七天搞定node.js---第一天]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%AD%A6%E4%B9%A0node.js%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[最近在学习node.js，记录一下自己的学习过程和一些笔记。 node.js介绍为什么要学习node.js 企业需求 具有服务端开发经验更好 font-end back-end 全栈开发工程师 全干 基本的网络开发能力 服务端 前端 运维部署 多人社区 node.js是什么 JavaScript 运行时 既不是语言，也不是框架，它是一个平台 node.js 中的 JavaScript 没有BOM、DOM EcmaScript基本的JavaScript 在 node 中为 JavaScript 提供了一些服务器级别的 API 文件操作的能力 http 服务的能力 模块系统 在 node 中没有全局作用域的概念 在 node 中只能通过 require 方法来加载执行多个 JavaScript 脚本文件 require 加载只能是执行其中的代码,文件与文件之间由于是模块作用域，所以不会有污染的问题。 模块完全是封闭的 外部无法访问内部 内部也无法访问外部 模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量名冲突的问题。 但是某些情况下，模块与模块是需要进行通信的 在每一个模块中，都提供了一个对象：exports 该对象默认是一个空对象 你要做的就是把需要被外部访问使用的成员手动的挂载到exports接口对象中 然后谁来require这个模块，谁就可以得到模块内部的exports接口对象 核心模块 核心模块是由 node 提供的一个个的具名的模块，它们都有自己特殊的名称表示，例如 fs 文件操作模块 http 网络服务构建模块 os 操作系统信息模块 path 路径处理模块 …… 所有核心模块在使用的时候都必须手动的先使用require方法来加载，然后才可以使用，例如： var fs = require(&#39;fs&#39;) http require 端口号 ip 地址定位计算机 端口号定位具体的应用程序 Content-Type 通过网络发送文件 发送的并不是文件，本质上来讲发送的是文件内容 当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理 起步还是 node 环境的安装 查看当前 node 环境的版本号 下载 https://nodejs.org/en/download/ 安装 傻瓜式的一路next就好了 对于已经安装过的，重新安装就会升级 确认 node 环境是否安装成功 打开命令行，输入node --version 或者node -v查看版本号 环境变量 Hello World解析执行 JavaScript1.创建编写 JavaScript 脚本文件2.打开终端，定位到脚本文件所属目录3.输入node 文件名执行对应文件注意：文件不要使用node.js来命名，也就是说除了 node 这个名字其他随便取(不要太过分~)，而且最好也不要使用中文。 文件的读写文件读取：12345678910111213141516171819202122232425var file_system = require(&apos;fs&apos;) // 读取文件有2参数 // 第一个参数是文件地址 // 第二个参数是一个回调函数： // 成功： // data是数据 // error是null // 失败： // data是undefind // error是错误对象file_system.readFile(&apos;./doc.txt&apos;, function(error, data) &#123; //&lt;Buffer e5 ad a6 e4 b9 a0 6e 6f 64 65 2e 6a 73 e7 9a 84 e7 ac ac e4 b8 80 e5 a4 a9 e3 80 82&gt; 储存的是二进制数据 // 二进制转换为16进制了，所以看到的不是 0 1 // 用tostring方法转换为我们可以阅读的字体 // console.log(error) // console.log(data) // console.log(data.toString()) //这里就可以通过判断 error 来确认是否有错误发生 if(error)&#123; console.log(&apos;文件读取失败~&apos;) &#125;else&#123; console.log(data.toString()) &#125;&#125;) 文件写入：12345678910111213141516171819202122232425262728var fs = request(&apos;fs&apos;)//$.ajax(&#123;// ...// success:function (data)&#123;// &#125;//&#125;)//第一个参数：文件路径//第二个参数：文件内容//第三个参数：回调函数// error//// 成功：// 文件写入成功// error 是 null// 失败：// 文件写入失败// error 就是错误对象fs.writeFile(&apos;./data/你好.md/(text)&apos;,&apos;大家好，给大家介绍一下，我是Node.js&apos;,function(error)&#123;// console.log(&apos;文件写入成功&apos;)// console.log(error) if(error)&#123; console.log(&apos;写入失败&apos;) &#125;else&#123; console.log(&apos;写入成功&apos;) &#125;&#125;) http一个很傻的服务器：123456789101112131415161718192021222324252627282930// 你可以使用 node 非常轻松的构建一个 web 服务器// 在 node 中专门提供了一个核心模块：http// http 这个模块的职责就是帮助你创建缩写服务器的//1、加载 http 核心模块var http = require(&apos;http&apos;)//2、使用 http.createServer() 方法创建一个 web 服务器// 返回一个 Server 实例var server = http.createServer()//3、服务器要干什么？// 提供服务：对数据的服务// 发请求// 接收请求// 处理请求// 给个反馈（发送响应）// 注册 request 请求事件// 当客户端发送请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数//server.on(&apos;request&apos;,function()&#123; console.log(&apos;收到客户端的请求了&apos;)&#125;)//4、绑定端口号，启动服务器server.listen(3000,function()&#123; console.log(&apos;服务器启动成功了,可以通过 http://127.0.0.1:3000/ 来进行访问 &apos;)&#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var http = require(&apos;http&apos;)//1、创建Servervar server = http.createServer() //2、createServer (http-res-url.js)请求处理函数server.on(&apos;request&apos;, function(req, res) &#123; // console.log(&apos;收到请求了，请求路径是：&apos; + req.url) // res.write(&apos;hello&apos;) // res.write(&apos;world&apos;) // res.end() //上面的方式比较麻烦，推荐使用更简洁的方式，直接end的同时发送响应数据。 // res.end(&apos;hello nodejs&apos;) //根据不同的请求路径发送不同的响应结果 // 1、获取请求路径 // req.url 获取的是端口号之后的那一部分路径 // 也就是说所有的 url 都是以 / 开头的 // 2、判断路径处理响应 var url = req.url // if (url === &apos;/&apos;) &#123; // res.end(&apos;index page&apos;) // &#125; else if (url === &apos;/login&apos;) &#123; // res.end(&apos;login page&apos;) // &#125; else &#123; // res.end(&apos;404 Not Found&apos;) // &#125; //学会了这些就能写简单版的接口了，例如： if (url === &apos;/products&apos;) &#123; var products = [&#123; name: &apos;iphone X&apos;, price: 8888 &#125;, &#123; name: &apos;华为&apos;, price: 6000 &#125;, &#123; name: &apos;小米&apos;, price: 3000 &#125;, &#123; name: &apos;魅族&apos;, price: 2500 &#125;, &#123; name: &apos;1+&apos;, price: 3500 &#125;, ] //响应内容只能是二进制数据或者字符串 //数字、对象、数组、布尔值通通无效 //数组转字符串 JSON.stringify() res.end(JSON.stringify(products)) &#125; &#125;) //3、绑定端口号，启动服务server.listen(3000, function() &#123; console.log(&apos;服务器启动成功，可以正常访问了~~&apos;)&#125;) 解决编码问题123456789101112131415var http = require(&apos;http&apos;)var server = http.createServer()server.on(&apos;request&apos;, function(req, res) &#123; //在服务端默认发送的数据，其实是 utf8 编码的内容 //但是浏览器不知道你是 utf8 编码内容 //浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统的默认编码去解析 //中文操作系统默认编码是 gdk //解决方法就是正确的告诉浏览器我给你发送的内容是什么编码的 res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;) res.end(&apos;你好，世界&apos;)&#125;)server.listen(3000, function() &#123; console.log(&apos;Server is running...&apos;)&#125;) Content-Type类型1234567891011121314151617181920212223242526272829303132var http = require(&apos;http&apos;)var server = http.createServer()server.on(&apos;request&apos;, function(req, res) &#123; //在服务端默认发送的数据，其实是 utf8 编码的内容 //但是浏览器不知道你是 utf8 编码内容 //浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统的默认编码去解析 //中文操作系统默认编码是 gdk //解决方法就是正确的告诉浏览器我给你发送的内容是什么编码的 //在 http 协议中，&apos;Content-type&apos;,就是用来告诉对方我给你发送的数据内容是什么类型 // res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;) // res.end(&apos;你好，世界&apos;) var url = req.url if (url === &apos;/plain&apos;) &#123; //text/plain就是普通文本 res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;) res.end(&apos;你好，世界&apos;) &#125; else if (url === &apos;/html&apos;) &#123; //如果你发送的是html格式的字符串，也要告诉浏览器发送的是html格式的 res.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;) res.end(&apos;&lt;h1&gt;你好,html&lt;h1&gt;&apos;) &#125;&#125;)server.listen(3000, function() &#123; console.log(&apos;Server is running...&apos;)&#125;) node中的JavaScript核心模块Node 为 JavaScript 提供了很多服务器级别的API，这些API绝大多数都被包装到了一个具体的核心模块中了。例如文件操作fs核心模块，http服务构建的http模块，path路径操作模块、os操作系统信息模块……12345678910 //获取机器信息var os = require(&apos;os&apos;) //操作路径var path = require(&apos;path&apos;) //获取当前机器的 cpu 信息console.log(os.cpus()) //memory 内存console.log(os.totalmem()) //extname extension nameconsole.log(path.extname(&apos;c:/a/b/c/d/hello.txt&apos;)) 更多模块用法参考官网 Web服务器开发ip地址和端口号 ip地址用来定位计算机 端口号用来定位具体的应用程序 一切需要联网通信的软件都会占用一个端口号 端口号范围从0~65536之间 在计算机中有一些默认端口号，最好不要去使用 例如 http 服务的80 我们在开发过程中使用一些简单好记的端口号就行了，例如3000、5000等 可以同时开启多个服务，但一定要确保不同服务占用的端口号要不一样 Content-Type可以在这里查询对应的Content-Type：http://tool.oschina.net/1234567891011121314151617181920212223242526272829303132333435363738394041424344//1、结合 fs 发送文件中的数据//2、Content-Type// http://tool.oschina.net/commons// 不同的资源对应的 Content-Type 是不一样的// 图片不需要指定编码// 一般只为字符数据才指定编码var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var server = http.createServer()server.on(&apos;request&apos;, function(req, res) &#123; var url = req.url if (url === &apos;/&apos;) &#123; fs.readFile(&apos;../resource/index.html&apos;, function(err, data) &#123; if (err) &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf8&apos;) res.end(&apos;文件读取失败，请稍后重试~&apos;) &#125; else &#123; //data默认是二进制数据，可以通过 .toString转为我们认识的字符串 //res.end()刚好支持两种数据类型，一种是二进制，一种是字符串 res.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf8&apos;) res.end(data) &#125; &#125;) &#125; else if (url === &apos;/picture&apos;) &#123; //url：统一资源定位符 //一个 url 最终其实是要对应到一个资源的 fs.readFile(&apos;../resource/preview.jpg&apos;, function(err, data) &#123; if (err) &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf8&apos;) res.end(&apos;文件读取失败，请稍后重试~&apos;) &#125; else &#123; //图片就不需要指定编码了，因为我们常说的编码一般是：指字符编码 res.setHeader(&apos;Content-Type&apos;, &apos;image/jpeg&apos;) res.end(data) &#125; &#125;) &#125;&#125;)server.listen(3000, function() &#123; console.log(&apos;Server is running...&apos;)&#125;) 请求对象 Request响应对象 Request在 node 中使用模板引擎统一处理静态资源服务端渲染源代码可以去我的 github 克隆]]></content>
      <categories>
        <category>进阶</category>
        <category>技术</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7个JavaScript小技巧，让前端的代码更高效！]]></title>
    <url>%2F2019%2F07%2F31%2F%E8%AE%A9%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%9B%B4%E9%AB%98%E6%95%88%2F</url>
    <content type="text"><![CDATA[JavaScript是前端开发人员必学的一门语言。本文共列举了7个小技巧来让你的代码更加简洁、更加高效！ 1、async / await如果你还陷入到回调地狱中，那么你应该回到2014年去开发你的代码。除非绝对必要（像第三方库需要或者性能原因），否则不要使用回调。Promise是非常好的解决回调地狱，但是当你的代码变得越来越大时，它也会变得不太好用。我现在的解决方案就是async / await，它极大提高了代码可读性以及简洁性。 在所有使用Promise的地方你都可以替换成await，在你需要返回Promise对象，简单await它并返回，为了使它不报错，你需要在定义函数的开头添加async。事实上，async / await就是Promise的语法糖。下面就是一个简单的例子：12345678910async function getData() &#123; const result = await axios.get(&apos;https://dube.io/service/ping&apos;) const data = result.data console.log(&apos;data&apos;, data) return data&#125; getData() await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。async / await是属于ES2017的内容，所以可能需要babel编译你的代码。不过现在的主流浏览器都已经支持了。 2、异步控制流经常地，我们会遇到这样的需求，请求获取多个数据集并对每个数据集进行各自处理或者需要等所有异步回调完成后返回一个值。遇到这些情况，我是这么处理的：1for…of 假设我们的页面有多个Pokemon（口袋妖怪），需要获取到它们的详细的信息。我们不想等所有调用结束，特别是不知道它有多少次调用，我们仅想在它有调用返回时就更新我们的数据集。可以用for…of来遍历数组，在代码块里执行async，这样的话，只有每次await执行成功，代码才会继续往下执行。 这里要着重说明，这样做可能会导致性能瓶颈（当请求很多的时候），但像这样做才能到达预期的效果。请看下面的例子：1234567891011121314151617181920212223import axios from &apos;axios&apos;let myData = [&#123;id: 0&#125;, &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;] async function fetchData(dataSet) &#123; for(entry of dataSet) &#123; const result = await axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`) const newData = result.data updateData(newData) console.log(myData) &#125;&#125; function updateData(newData) &#123; myData = myData.map(el =&gt; &#123; if(el.id === newData.id) return newData return el &#125;)&#125; fetchData(myData) 这个代码是能正常运行，你可以轻松地复制它到 code sandbox运行。1Promise.all 如果你想同时获取所有口袋妖怪的详情呢？你需要等待所有的请求的完成返回，这时简单使用1234567891011121314151617181920212223242526272829Promise.all： import axios from &apos;axios&apos; let myData = [&#123;id: 0&#125;, &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;] async function fetchData(dataSet) &#123; const pokemonPromises = dataSet.map(entry =&gt; &#123; return axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`) &#125;) const results = await Promise.all(pokemonPromises) results.forEach(result =&gt; &#123; updateData(result.data) &#125;) console.log(myData)&#125; function updateData(newData) &#123; myData = myData.map(el =&gt; &#123; if(el.id === newData.id) return newData return el &#125;)&#125; fetchData(myData) for…of 和 Promise.all都是ES6以后提出来的，请确保你的环境能运行。 3、解构（Destructuring ） &amp; 默认值我们接着上面的那个例子，提取一部分代码：12const result = axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`)const data = result.data 有一种简单的方法，解构从数组，或对象中获取一些属性（值）。像这样：1const &#123; data &#125; = await axios.get(...) 注意当解构的时候，通常要赋给它一个默认值。这样确保你不会得到undefined以及你不用自己手动地检查变量。12const &#123; id = 5 &#125; = &#123;&#125;console.log(id) // 5 这个技巧也被运用到了函数参数中。例如：123456789101112131415161718function calculate(&#123;operands = [1, 2], type = &apos;addition&apos;&#125; = &#123;&#125;) &#123; return operands.reduce((acc, val) =&gt; &#123; switch(type) &#123; case &apos;addition&apos;: return acc + val case &apos;subtraction&apos;: return acc - val case &apos;multiplication&apos;: return acc * val case &apos;division&apos;: return acc / val &#125; &#125;, [&apos;addition&apos;, &apos;subtraction&apos;].includes(type) ? 0 : 1)&#125; console.log(calculate()) // 3console.log(calculate(&#123;type: &apos;division&apos;&#125;)) // 0.5console.log(calculate(&#123;operands: [2, 3, 4], type: &apos;multiplication&apos;&#125;)) // 24 这个例子起初看起来可能有点混乱，但是慢慢观察。当我们没有给函数传递参数的时候，就会使用默认值。一旦我们开始传递参数，仅会使用那些没有传递的参数的默认值。这样，减少了你对异常状态的处理。 4、真值 &amp; 假值当使用默认值，就可以不用对现有值进行一些额外的检查。但是了解你的变量是真值还是假值是非常棒的。它能提高你的代码扩展性，更具有说服力的以及简洁。我常看到下面一些写法：1234567891011if(myBool === true) &#123; console.log(...)&#125;// ORif(myString.length &gt; 0) &#123; console.log(...)&#125;// ORif(isNaN(myNumber)) &#123; console.log(...)&#125; 为了用这些简洁的判断，你要充分理解js中真值，假值具体有哪些？这里概述一下： 假值：12345671.字符串，但长度为02.数字03.false4.undefined5.null6.NaN 真值：12341.空数组2.空对象3.其他有值的数据.注意：在判断真/假值，还应该注意到你使用的是等于&apos;==&apos;，还是全等&apos;===&apos;,这经常会导致bug。对我而言，经常是数字0。 5、逻辑运算与三元运算符逻辑运算 逻辑运算是基于多个表达式真假的判断，注意到js是惰性求值的策略。逻辑运算一般返回一个布尔值。&amp;&amp; 和 || 运算符会返回一个指定操作数的值。来看这里：12345678console.log(true &amp;&amp; true) // trueconsole.log(false &amp;&amp; true) // falseconsole.log(true &amp;&amp; false) // falseconsole.log(false &amp;&amp; false) // falseconsole.log(true || true) // trueconsole.log(true || false) // trueconsole.log(false || true) // trueconsole.log(false || false) // false 进行的逻辑运算，是按照下面的规则进行的： &amp;&amp;:第一个值为假值，则直接返回；如果为真值，则直接返回第二的值 ||:第一个值为真，则直接返回；如果为假，则直接返回第二的值。123456console.log(0 &amp;&amp; &#123;a: 1&#125;) // 0console.log(false &amp;&amp; &apos;a&apos;) // falseconsole.log(&apos;2&apos; &amp;&amp; 5) // 5console.log([] || false) // []console.log(NaN || null) // nullconsole.log(true || &apos;a&apos;) // true 三元运算符 三元运算符和逻辑运算是相似的，但是它有3个部分：1condition ? expr1 : expr2 condition为进行条件判断的部分，将会得到真值或者假值 expr1为条件判断为真时返回的值 expr2为条件判断为假时返回的值 例如：1234constconsole.log(lang === &apos;German&apos; ? &apos;Hallo&apos; : &apos;Hello&apos;) // Halloconsole.log(lang ? &apos;Ja&apos; : &apos;Yes&apos;) // Jaconsole.log(lang === &apos;French&apos; ? &apos;Bon soir&apos; : &apos;Good evening&apos;) // Good evening 6、Optional Chaining过去在 Object 属性链的调用中，很容易因为某个属性不存在而导致之后出现Cannot read property xxx of undefined的错误。为了确认需要向这样处理：12let dataif(myObj &amp;&amp; myObj.firstProp &amp;&amp; myObj.firstProp.secondProp &amp;&amp; myObj.firstProp.secondProp.actualData) data = myObj.firstProp.secondProp.actualData 这样事冗余的，有一个新的提案的方法就是Optional Chaining，如下的形式：1const data = myObj?.firstProp?.secondProp?.actualData 我认为它是检查嵌套属性最佳方法，代码是如此的简洁。 这个特性可以说是非常实用了，不过它现在处于 stage-1 阶段。你可以在.babelrc文件中引入 @babel/plugin-proposal-optional-chaining插件来使用它。 7、Class properties &amp; binding在JavaScript中函数绑定也是经常的工作任务。现在，大家应该都是用箭头函数自动绑定this到这个类上的（这里可能有歧义，首先箭头函数里面是没有this 和arguments的，这里的this把它当成一个参数就行）。 如果不用箭头函数，我们就需要在构造函数绑定this，当类的方法很多的时候，这就显得很冗余。因此，建议和提倡在类里面用箭头函数。如：1234567891011121314151617181920class Counter extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; render() &#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this._increaseCount&#125;&gt;Increase Count&lt;/button&gt; &lt;/div&gt; ) &#125; _increaseCount = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125; 使用箭头函数声明类中方法，它现在处于 stage-3 阶段。你可以在.babelrc文件中引入@babel/plugin-proposal-class-properties插件来使用它。 *声明：本文于网络整理，版权归原作者所有，如来源信息有误或侵犯权益，请联系我删除或授权事宜]]></content>
      <categories>
        <category>前端进阶</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地模拟后端数据的第三种方法]]></title>
    <url>%2F2019%2F07%2F30%2F%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这里介绍了第三种本地模拟后端接口的方法，使用第三方框架（mockjs）,拦截ajax请求返回数据。官网 1、引入mockjs,可以是在线地址，或者是下载到本地引入，一般在body结束标签前引入。123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;title&gt;第三方框架，mockjs拦截ajax请求返回数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--内容--&gt;&lt;!--body结束标签前引用--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、根据数据模板生成模拟数据。（一般场景配置两个参数够用了Mock.mock( rurl, template )） Mock.mock( rurl?, rtype?, template|function( options ) )。 rurl（可选）。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 //domain/list.json/、’/domian/list.json’。 rtype（可选）。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 template （可选）。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 function(options)（可选）。表示用于生成响应数据的函数。 options 指向本次请求的 Ajax 选项集，含有 url、type 和 body 三个属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- （必选）加载 Mock --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; /* * Mock.mock( rurl, template ) * rurl:表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。 * template：表示数据模板，可以是对象或字符串 * */// mock拦截ajax请求并返回数据 Mock.mock(/\.json/, &#123; &apos;code&apos;:&apos;000&apos;, &apos;message&apos;:&apos;message信息&apos;, &apos;list|1-10&apos;: [&#123; &apos;id|+1&apos;: 1, &apos;email&apos;: &apos;@EMAIL&apos;, &apos;name&apos;: &apos;@name&apos; &#125;] &#125;) $.ajax(&#123; url:&apos;list.json&apos;, contentType: &apos;application/json&apos;, type: &apos;POST&apos;, timeout: 5000, dataType:&apos;JSON&apos;, data: JSON.stringify(&#123;schoolId: 123&#125;), success: function (res) &#123; if(res.code == 000)&#123; console.log(res); $(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(res, null, 4)).appendTo(&apos;body&apos;); &#125;else&#123; alert(res.message); &#125; &#125;, Error: function (xhr, type, errorThrown) &#123; console.log(JSON.stringify(xhr)); console.log(type); console.log(errorThrown); &#125; &#125;); &#125;)&lt;/script&gt; 把html文件在浏览器里打开，出现以下格式的json数据； 注意：每次打开页面或刷新一次页面数据会随机改变； 123456789101112131415161718192021&#123; &quot;code&quot;: &quot;000&quot;, &quot;message&quot;: &quot;message信息&quot;, &quot;list&quot;: [ &#123; &quot;id&quot;: 1, &quot;email&quot;: &quot;u.skubdwsbs@nfuzlwgd.et&quot;, &quot;name&quot;: &quot;Michael Clark&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;email&quot;: &quot;u.sokjrkoja@lnmxlkx.kp&quot;, &quot;name&quot;: &quot;Brian Davis&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;email&quot;: &quot;t.chpjw@jnidn.se&quot;, &quot;name&quot;: &quot;Margaret Allen&quot; &#125; ]&#125; 3、可选）配置拦截ajax请求时的行为； Mock.setup( settings )； settings必选，支持的配置项有：timeout； 指定被拦截的 Ajax 请求的响应时间，单位是毫秒。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- （必选）加载 Mock --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123;// mock拦截ajax请求并返回数据 Mock.mock(/\.json/, &#123; &apos;code&apos;:&apos;000&apos;, &apos;message&apos;:&apos;message信息&apos;, &apos;list|1-10&apos;: [&#123; &apos;id|+1&apos;: 1, &apos;email&apos;: &apos;@EMAIL&apos;, &apos;name&apos;: &apos;@name&apos; &#125;] &#125;) /* * Mock.setup( settings ) * 配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。 * settings必选。配置项集合。timeout可选。指定被拦截的 Ajax 请求的响应时间，单位是毫秒。值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；也可以是横杠 &apos;-&apos; 风格的字符串，例如 &apos;200-600&apos;，表示响应时间介于 200 和 600 毫秒之间。默认值是&apos;10-100&apos;。*/ Mock.setup(&#123; timeout: 4000 &#125;) $.ajax(&#123; url:&apos;list.json&apos;, contentType: &apos;application/json&apos;, type: &apos;POST&apos;, timeout: 5000, dataType:&apos;JSON&apos;, data: JSON.stringify(&#123;schoolId: 123&#125;), success: function (res) &#123; if(res.code == 000)&#123; console.log(res); $(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(res, null, 4)).appendTo(&apos;body&apos;); &#125;else&#123; alert(res.message); &#125; &#125;, Error: function (xhr, type, errorThrown) &#123; console.log(JSON.stringify(xhr)); console.log(type); console.log(errorThrown); &#125; &#125;); &#125;)&lt;/script&gt; 配置Mock.setup({timeout: 4000})之后网页打开4000毫秒之后才会返回数据; Mock.Random 是一个工具类，用于生成各种随机数据。（其实上面例子中已经有使用） Mock.Random 提供的完整方法（占位符）如下： 基本：boolean, natural, integer, float, character, string, range, 时间：date, time, datetime, now； 图片：image, dataImage； 颜色：color，hex，rgb，rgba，hsl； 文本：paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle； 名字：first, last, name, cfirst, clast, cname； web：url, domain, email, ip, tld； 地址：region，province，city，county，zip； Helper：capitalize, upper, lower, pick, shuffle； Miscellaneous：guid, id, increment; 使用方法：在模板数据中定义参数,值为@加上对应的占位符用引号引起来，比如&#39;nowTime&#39;:&#39;@now&#39;,请求返回的数据就是当前发送请求时的时间 “2017-09-02 11:42:06”；下面我使用了三个占位符，12345678910Mock.mock(/\.json/, &#123; &apos;code&apos;:&apos;000&apos;, &apos;message&apos;:&apos;message信息&apos;, &apos;list|1-10&apos;: [&#123; &apos;id|+1&apos;: 1, &apos;email&apos;: &apos;@EMAIL&apos;, //邮箱 &apos;name&apos;: &apos;@name&apos;， //名字 &apos;time&apos;:&apos;@now&apos; //当前时间 &#125;]&#125;) 页面显示：123456789101112131415161718192021222324&#123; &quot;code&quot;: &quot;000&quot;, &quot;message&quot;: &quot;message信息&quot;, &quot;list&quot;: [ &#123; &quot;id&quot;: 1, &quot;email&quot;: &quot;z.urorqdo@prrfhjnly.mil&quot;, &quot;name&quot;: &quot;Joseph Taylor&quot;, &quot;time&quot;: &quot;2017-09-02 11:42:06&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;email&quot;: &quot;m.oshsxmd@ewcolhl.na&quot;, &quot;name&quot;: &quot;Mary Harris&quot;, &quot;time&quot;: &quot;2017-09-02 11:42:06&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;email&quot;: &quot;l.zcbunjphx@hvdgteo.ir&quot;, &quot;name&quot;: &quot;Susan Thomas&quot;, &quot;time&quot;: &quot;2017-09-02 11:42:06&quot; &#125; ]&#125; 这里简单介绍一下mockjs怎么使用的，想了解更详细的使用，请参考官方文档和官方示例，写的很详细，这里就不多说了还有Mock.valid( template, data )效验真实数据的方法，个人觉得用的不多，想了解的自行查看文档。 前2种方法快速链接：方法一：基于node.js方法二：请求本地json文件]]></content>
      <categories>
        <category>模拟后端接口</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>mockjs</tag>
        <tag>本地模拟后端数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之新增看板娘(能说话、能换装)]]></title>
    <url>%2F2019%2F07%2F30%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%96%B0%E5%A2%9E%E7%9C%8B%E6%9D%BF%E5%A8%98(%E8%83%BD%E8%AF%B4%E8%AF%9D%E3%80%81%E8%83%BD%E6%8D%A2%E8%A3%85)%2F</url>
    <content type="text"><![CDATA[今天在逛别博客的时候，发现了高级版的看板娘，很是心动，马上给自己的博客也来了一个。更多效果展示，请访问我的个人博客 1、最终效果图 2、教程：2.1、小白水平：hexo的官方是支持看板娘的，已经封装好了插件，但只是模型，不能说话、不能换装、功能较少。 2.1.1、安装模块，如下：1npm install --save hexo-helper-live2d 在 站点配置文件 或 主题配置文件 中新增如下内容：12345678910111213141516171819202122232425# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right width: 150 height: 300 mobile: show: true # 手机中是否展示 选择自己喜欢的模型可以参考我下面的一篇博客—–Hexo博客美化 2.1.2、小白水平，效果如下：这里主要介绍的是大神水平，想弄这样比较低级一点的可以参考我的另外一篇博客——Hexo博客美化 2.2、大神水平：大神作品，功能齐全。能说话、能换装、能玩游戏、能拍照、还能自定义。 2.2.1、下载张书樵大神的项目，解压到本地博客目录的themes/next/source下，修改autoload.js文件，如下：1const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/&quot;; 改为1const live2d_path = &quot;/live2d-widget/&quot;; 2.3、在/themes/next/layout/_layout.swing中,新增如下内容：1&lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 2.4、在 主题配置文件 中,新增如下内容：12live2d: enable: true 2.5、想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 和 waifu.css。2.6、大神水平，效果如下：]]></content>
      <categories>
        <category>美化hexo博客</category>
      </categories>
      <tags>
        <tag>博客美化</tag>
        <tag>萌妹子</tag>
        <tag>肥宅必备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二种方法，请求本地 json 文件，返回数据。]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%9C%AC%E5%9C%B0%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[之前介绍过用node.js写一个本地的接口来进行调试，现在再来介绍一下第二种方法，似乎比之前那种要简单许多。 1、注意json格式；1234567891011121314151617// list.json&#123; &quot;code&quot;:&quot;000&quot;, &quot;message&quot;:&quot;message信息&quot;, &quot;lists&quot;:[ &#123; &quot;name&quot;:&quot;小明&quot;, &quot;sex&quot;:&quot;男&quot;, &quot;age&quot;: &quot;3&quot; &#125;, &#123; &quot;name&quot;:&quot;小红&quot;, &quot;sex&quot;:&quot;女&quot;, &quot;age&quot;:&quot;3&quot; &#125; ]&#125; 2、请求路径是相对路径，相对于当前发送请求的文件。1234// 项目路径.├──index.html└──list.json 123456789101112131415161718192021222324252627282930313233343536373839// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;title&gt;请求本地json文件数据&lt;/title&gt; &lt;!--&lt;script src=&quot;../js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;--&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; // 请求路径是当前文件的相对路径 $.ajax(&#123; url:&apos;list.json&apos;, contentType: &apos;application/json&apos;, type: &apos;POST&apos;, timeout: 5000, dataType:&apos;JSON&apos;, data: JSON.stringify(&#123;schoolId: 123&#125;), success: function (res) &#123; if(res.code == &apos;000&apos;)&#123; console.log(res); $(&apos;body&apos;).html(JSON.stringify(res)); &#125;else&#123; alert(res.message); &#125; &#125;, Error: function (xhr, type, errorThrown) &#123; console.log(JSON.stringify(xhr)); console.log(type); console.log(errorThrown); &#125; &#125;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第1种方法快速链接：方法一：基于node.js]]></content>
      <categories>
        <category>模拟后端接口</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>本地模拟后端数据接口</tag>
        <tag>json格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用node.js搭建简单服务器接收请求返回数据,在本地实现模拟后端数据接口。]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BD%BF%E7%94%A8node%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[引言：&emsp;&emsp;不知道你在项目开发过程中，有没有遇到过有过以下场景： 一般是前端先制作静态页面，同时服务器端创建数据库，搭服务器端架构，写接口； 当接口写完之后，前端或者后端才能嵌套页面。 但是，如果前端页面制作好了，后端接口还没有写好呢？或者如何让前端、后端各自做各自的事情，互相不影响？ 能做到下面这样是不是很好呢？ ——在进行完需求分析和详细设计后，前端、后端一同商量、制作出一份接口文档 （其中接口名、参数、返回值名称、返回值类型都定义好） 前端页面制作好之后，直接模拟出该接口的json文件，先去请求该文件，把页面绑定、业务逻辑都处理好。 等前端全部绑定好，同时后端接口写好后，我们只需要前端修改接口地址，其他不用做任何修改。 这样，是不是前端不用等后端接口全部写完才能开始剩下的工作呢？ 1、起手式，不用说肯定是安装node 没有什么难度，去官网下载，简单粗暴一直下一步，完成安装。可以参考下菜鸟教程中关于node.js安装配置； 安装node 会自动安装npm包管理工具； 检查是否有安装node和 npm包管理工具，打开cmd命令行工具，输入node -v 和npm -v，会输出对应的版本号，如下图所示： 全局安装 npm ,最好同时安装cnpm 淘宝npm镜像，如果npm 安装依赖包的时候报错，有时候是网络不好，可以使用淘宝镜像cnpm来安装；12npm install -g npmnpm install -g cnpm 2、安装express应用程序生成器官网 全局安装express-generator; 1npm install -g express-generator 有安装Git Bash Here等第三方命令行工具，我们打开文件管理，进入到想要生成项目的位置后，右键打开Git Bash Here 就可以在当前位置启动命令行工具了； 如果没有安装git等第三方cmd命令行工具，我们打开文件管理，进入到想要生成项目的位置后，直接在地址栏输入cmd，会在当前目录打开cdm命令行工具； 在我们想要的位置打开命令行工具之后，就可以开始以下步骤： 创建一个名为myapp的express应用程序1express --view=pug myapp 成功后会自动在目标位置创建一个名为myapp的项目并生成很多文件，命令行显示效果如下图：在命令行最下面有提示，install dependencies: cd myapp &amp;&amp; npm install 然后 run the app: npm start,我们按照提示来； 进入myapp项目； 1cd myapp 安装package.json文件中的依赖； 1npm install 网络不好可以用cnpm 1cnpm install 运行项目 1npm start 在浏览器输入localhost:3000，会打开一个页面显示Welcome to Express，说明已经成功启动服务了。 3、相关配置 打开myapp项目，可以看到目录下面的结构是这样的； 这个时候，浏览器打开localhost:3000/users,可以看到页面显示respond with a resource 打开routes 文件夹下的users看到以下代码： 可以看到页面显示的内容就是users.js文件中返回的内容，我们定义自己想要返回的内容。 改了之后再请求没有改变，查看命令行信息，304发现我们的请求给我们缓存了； 我们重新启动一下试试，刷新页面返回： 12345678910111213141516&#123; &quot;code&quot;: &quot;000&quot;, &quot;message&quot;: &quot;message消息&quot;, &quot;lists&quot;: [ &#123; &quot;naem&quot;: &quot;小明&quot;, &quot;age&quot;: &quot;12&quot;, &quot;sex&quot;: &quot;男&quot; &#125;, &#123; &quot;naem&quot;: &quot;小红&quot;, &quot;age&quot;: &quot;12&quot;, &quot;sex&quot;: &quot;女&quot; &#125; ]&#125; 这样虽然可以请求，但是有缓存问题，而且接口多的话每次都得配置一个路径，太复杂，所以要封装一下，重复使用，每次请求重新请求不加载缓存。 在项目下新建一个config文件夹并新建一个api.js,配置一下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// config/api.jsvar fs = require(&apos;fs&apos;);/** * 检查请求的路径是否存在 * @param apiName 请求路径 * @param method 请求方式 * @param params 请求参数 * @param res 返回请求 */function getDataFromPath (apiName,method,params,res)&#123; if(apiName)&#123; fs.access( // 提取请求路径中的js文件 apiName.substring(1)+&apos;.js&apos;, // 回调函数，检查请求的路径是否有效失败返回一个错误参数 function(err)&#123; if(!err)&#123; // 每次请求都清除模块缓存重新请求 delete require.cache[require.resolve(&apos;..&apos;+apiName)]; try&#123; addApiResult(res,require(&apos;..&apos;+apiName).getData(method,params)); &#125;catch(e)&#123; console.error(e.stack); res.status(500).send(apiName+&apos; has an error,please check the code.&apos;); &#125; &#125;else&#123; addApiResult(res); &#125; &#125; ); &#125;else&#123; addApiResult(res); &#125;&#125;;/** * 响应头 * @param res */function addApiHead(res)&#123; res.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;); // 跨域 res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&apos;); res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT, POST, GET, DELETE, OPTIONS&apos;); // 控制http缓存 res.header(&quot;Cache-Control&quot;, &quot;no-cache, no-store, must-revalidate&quot;); res.header(&quot;Pragma&quot;, &quot;no-cache&quot;); res.header(&quot;Expires&quot;, 0);&#125;/** * 返回参数，如无返回参数返回404 * @param res * @param result */function addApiResult(res,result)&#123; if(result)&#123; res.send(result); &#125;else&#123; res.status(404).send(); &#125;&#125;/*请求方式*/// getexports.get = function(req, res)&#123; addApiHead(res); getDataFromPath(req.path,&apos;GET&apos;,req.query,res);&#125;;// postexports.post = function(req, res)&#123; addApiHead(res); getDataFromPath(req.path,&apos;POST&apos;,req.body,res);&#125;; 打开根目录下app.js，在上面引入刚刚新建的文件api.js; 12//引入APIvar api = require(&apos;./config/api&apos;); 替换请求配置 123456/*配置请求*/app.get(&apos;/&apos;, function(req, res)&#123; res.send(&apos;hello world&apos;);&#125;);app.get(&apos;/api/*&apos;, api.get);app.post(&apos;/api/*&apos;, api.post); app.js最终代码 123456789101112131415161718192021222324252627282930313233343536373839// app.jsvar express = require(&apos;express&apos;);var path = require(&apos;path&apos;);var favicon = require(&apos;serve-favicon&apos;);var logger = require(&apos;morgan&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);var app = express();/*引入api*/var api = require(&apos;./config/api&apos;);// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;pug&apos;);// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, &apos;public&apos;, &apos;favicon.ico&apos;)));app.use(logger(&apos;dev&apos;));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &apos;public&apos;)));//配置请求app.get(&apos;/&apos;, function(req, res)&#123; res.send(&apos;hello world&apos;);&#125;);app.get(&apos;/api/*&apos;, api.get);app.post(&apos;/api/*&apos;, api.post);app.options(&apos;/api/*&apos;, function(req, res, next)&#123; res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&apos;); res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT, POST, GET, DELETE, OPTIONS&apos;); res.sendStatus(200);/*让options请求快速返回*/&#125;);module.exports = app; 根目录新建api文件夹，新建demo.js; 1234567891011121314151617181920212223242526272829303132// api/demo.jsvar dataDemo=&#123; &apos;code&apos;:&apos;000&apos;, &apos;message&apos;:&apos;message消息&apos;, &apos;lists&apos;:[ &#123; &apos;naem&apos;:&apos;小明&apos;, &apos;age&apos;: &apos;12&apos;, &apos;sex&apos;:&apos;男&apos; &#125;,&#123; &apos;naem&apos;:&apos;小红&apos;, &apos;age&apos;: &apos;12&apos;, &apos;sex&apos;:&apos;女&apos; &#125; ]&#125;exports.getData = function(method,data)&#123; var backData=&#123; &quot;code&quot;:&apos;000&apos;, &quot;msg&quot;:&quot;&quot;, &quot;data&quot;:dataDemo &#125; if(method==&apos;DELETE&apos;)&#123; backData=&#123; &quot;code&quot;:&apos;999&apos;, &quot;msg&quot;:&quot;不支持DELETE方法&quot; &#125; &#125; return JSON.stringify(backData);&#125;kData);&#125; 重新运行npm start，浏览器打开localhost:3000，此时应该显示的是hello world； 打开localhost:3000/api/demo,页面显示 以上都成功了，那就说明配置成功了，复制demo.js文件命名为demo2.js,改动一下数据，浏览器访问localhost:3000/api/demo2应该也是可以的； 4、使用假如线上接口是 https://xiaomujin.club/mydata/index/data/list,我们在api文件夹按照路径新建文件夹和文件即可:123456├── api│ └── mydata│ └── index│ └── data│ └── list.js 开发的时候指向本地服务器器接口，联调测试上线的时候只需要把指向本地服务器地址替换成线上地址一下就可以了。123456789101112131415161718192021222324252627&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; // var baseUrl = &apos;https://xiaomujin.club&apos;; //线上地址 var baseUrl = &apos;http://localhost:3000/api&apos;; //本地服务器地址 $.ajax(&#123; url: baseUrl+&apos;/mydata/index/data/list&apos;, contentType: &apos;application/json&apos;, type: &apos;POST&apos;, timeout: 5000, dataType:&apos;JSON&apos;, data: JSON.stringify(&#123;schoolId: 123&#125;), success: function (res) &#123; if(res.code == &apos;000&apos;)&#123; console.log(res); $(&apos;body&apos;).html(JSON.stringify(res)); &#125;else&#123; alert(res.message); &#125; &#125;, Error: function (xhr, type, errorThrown) &#123; console.log(JSON.stringify(xhr)); console.log(type); console.log(errorThrown); &#125; &#125;); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>前端</tag>
        <tag>本地模拟后端数据接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法使用]]></title>
    <url>%2F2019%2F07%2F26%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言写过博客或者github上面的文档的，应该知道Markdown语法的重要性，我自己就在把弄这个博客，写文章就是用的这个Markdown语法，本来也是完全不会的，用着用着就熟练了，很容易。 1、常用快捷键 功能 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y 2、基本语法2.1 字体设置斜体、粗体、删除线示例：12345**这是加粗的文字***这是倾斜的文字*_这是倾斜文字_***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字这是倾斜文字这是斜体加粗的文字这是加删除线的文字 2.2 分级标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题2.3 链接(1)插入图片&emsp;&emsp;注：图片描述不是必须的~1！[图片描述](图片本地url/网上url) (2)超连接给文字添加点击链接用下面第一种，直接输入链接也是可以点击的。 示例：12[点击进入我的blog] (www.xiaomujin.club)www.xiaomujin.club 效果： 点击进入我的blogwww.xiaomujin.club 2.4 分割线你可以在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号或是底线中间插入空格。 示例：123*****-----_____ 实现效果： (*)的底线 (-)的底线(3个以上的-号也相当于一个二级标题，3个以上的=号相当于一级标题)(_)的底线 2.5 代码块对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用反引号（一般在ESC键下方，和~同一个键）包裹代码。12多行代码块：（```这里一个多行代码块```）行内需要引用代码块：（`这是一个行内代码块`） 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理。 示例如下： 2.6 引用在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例：123&gt; ##### 引用1&gt; &gt; 引用2&gt; &gt; &gt; 引用3 效果如下： 有5级标题的引用1 引用2 引用3 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。2.7 列表(1）无序列表语法：无序列表用 - + * 任何一种都可以 示例： 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 (2)有序列表语法：数字加点 示例：123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果： 列表内容 列表内容 列表内容 (3)列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等。注意事项:&emsp;&emsp;在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。如下图所示 2.8 表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例：12345姓名|技能|排行:--:|:--:|:--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 3、常用技巧3.1 换行方法1: 连续两个以上空格+回车;方法2：使用html语言换行标签。 3.2 缩进字符示例：1234木槿前端不求人 //未缩进对比&amp;nbsp;木槿前端不求人 //缩进1/4个中文&amp;ensp;木槿前端不求人 //缩进半个中文，1个字符&amp;emsp;木槿前端不求人 //缩进一个中文，2个字符 效果如下： 木槿前端不求人&nbsp;木槿前端不求人&ensp;木槿前端不求人&emsp;木槿前端不求人]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JavaScript三大“黑话”]]></title>
    <url>%2F2019%2F07%2F24%2F%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript'%E9%BB%91%E8%AF%9D'%2F</url>
    <content type="text"><![CDATA[因为球是圆的，所以不论发生什么都有可能，对这点我是深信不疑的，但最近我总是在怀疑，JavaScript也是圆的！下面我们一起来看看JavaScript有啥黑话： 1.“算术”算术中的位运算已被作者列为禁术，因此希望你在工程中使用位运算时，请确保你有充足的理由使用，并在需要时写好Hack注释。 ！与 ！！&emsp;&emsp;!&nbsp;为逻辑非操作符，可以应用于ECMAScript中的任何值，无论这个值是什么类型，它会被强制转化为一个布尔值变量，再对其值取反。&emsp;&emsp;! !&nbsp;只是单纯的将操作数执行两次逻辑，他能将任意类型的值转化为相应的布尔值，它包含的步骤为： &emsp;&emsp;1.将一个值转化为布尔值； &emsp;&emsp;2.将其取反； &emsp;&emsp;3.再次取反。 假设你需要通过一个布尔型变量表示是否有ID值，以下写法推荐你使用最后一种方式来进行转化：123const enable1 = !!id;const enable2 = id ? true : false;const enable3 = Boolean(id); ~与 ~~~ 表示按位取反，~5的运算步骤为： &emsp;&emsp;1.转为一个字节的二进制表示：00000101； &emsp;&emsp;2.按位取反：11111010； &emsp;&emsp;3.取其反码：10000101； &emsp;&emsp;4.取其补码：10000110； &emsp;&emsp;5.转化为十进制：- 6。 ~~它代表双非按位取反运算符，如果你想使用比Math.floor()更快的方法，那就是它了。需要注意，对于正数，它向下取整；对于负数，向上取整；非数字取值为0，它具体的表现形式为：123456789101112~~null; // =&gt; 0~~undefined; // =&gt; 0~~Infinity; // =&gt; 0~~NaN; // =&gt; 0~~0; // =&gt; 0~~&#123;&#125;; // =&gt; 0~~[]; // =&gt; 0~~(1/0); // =&gt; 0~~false; // =&gt; 0~~true; // =&gt; 1~~1.9; // =&gt; 1~~-1.9; // =&gt; -1 +在变量值前使用+的本意是将变量转换为数字，在一个函数接受数字类型的参数时特别有用：1234+&apos;1&apos; // 1+&apos;-1&apos; // -1+[] // 0+&#123;&#125; // NaN 根据观察，+a与a * 1结果类似。除此之外，使用+也可以作为立即执行函数：+function(){}()，等效于(function( ){ })( )。 字符串与数字相加时会将数值默认转为字符串，因此有了一下将数字转为字符串的快捷方法：’’ + 1。 &amp;与 &amp;&amp;在JavaScript中，&amp;只能进行位运算。 &amp;，它表示按位与，此运算符需要两个数字并返回一个数字。如果它们不是数字，则会转换为数字。如果执行7 &amp; 3， 则会经过以下步骤： &emsp;&emsp;1.先转换为2进制： 111 &amp; 11； &emsp;&emsp;2.比较结果为： 011； &emsp;&emsp;3.将二进制转换回十进制，因此： 7 &amp; 3 = 3。 它也可以用于奇偶数判断：const isOdd = num =&gt; !!(num &amp; 1)。 &amp;&amp;，表示逻辑与，通常用于if条件判断，可跟你想象的不太一样，&amp;&amp;并不是单纯的返回true或者false，而是依据： &emsp;&emsp;1.若第一个表达式为false，则返回第一个表达式； &emsp;&emsp;2.若第一个表达式为true，返回第二个表达式。在这里举几个例子： 12340 &amp;&amp; false 0 (both are false-y, but 0 is the first)true &amp;&amp; false false (second one is false-y)true &amp;&amp; true true (both are true-y)true &amp;&amp; 20 20 (both are true-y) &emsp;&emsp;&amp;&amp;可以连接多个操作符，如：a &amp;&amp; b &amp;&amp; c &amp;&amp; d，返回值的规则与上面一样。除此以外，它还经常被作为短路逻辑使用：若前面表达式不是Truthy，则不会继续执行之后的表达式。如在取一个对象的属性，我们需要先判断是否为空才能进行取值，否则会抛出Uncaught TypeError，这种情况下一般我们也会通过逻辑或，给与表达式一个默认值：1const value = obj &amp;&amp; obj.value || false 当JavaScript压缩工具遇到 if 判断时，也会使用&amp;&amp;短路逻辑从而节省内存空间：1234// beforeif (test) &#123; alert(&apos;hello&apos;) &#125;// aftertest &amp;&amp; alert(&apos;hello&apos;) | 与 ||它们与&amp;和&amp;&amp;使用方法很相似，不同的是它们表示的是逻辑或，因此使用 | 会进行按位或运算，而 || 会返回第一个Truthy值。 使用 || 进行默认值赋值在JavaScript中十分常见，这样可以省略很多不必要的if语句，比如：1234567891011121314// beforelet res;if (a) &#123; res = a;&#125; else if (b) &#123; res = b;&#125; else if (c) &#123; res = c;&#125; else &#123; res = 1;&#125;// afterconst res = a || b || c || 1; = = 与 = = == =为相等运算符，操作符会先将左右两边的操作数强制转型，转换为相同的操作数，再进行相等性比较。 = = =为全等运算符，它除了在比较时不会将操作数强制转型，其余相等判断与= =一致。 &emsp;&emsp;简单而言，= =用于判断值是否相等，= = =判断值与类型是否都相等，因此使用全等运算符判断操作数会更准确，新手也在学习JavaScript接收到的前几条Tips就是避免使用相等运算符，真的是这样吗？没错，这样能确保在你不彻底熟悉语言的情况下，尽可能的去避免犯错，但是我们也应该清楚在哪些情况下应该使用相等运算符，规则往往只针对于新手，而对聪明的你来说，最重要的是要清楚自己在做什么。 相等操作符对于不同类型的值，进行的比较如下图所示： 针对于undefined与null：undefined与null互等，与其余任意对象都不相等，因此在某些lib里，你可能会看到如下写法：12if (VAR == undefined) &#123;&#125;if (VAR == null) &#123;&#125; 它等效于：1if (VAR === undefined || VAR === null) &#123;&#125; 对于 ‘ ‘, false, 0而言，他们都属于Falsy类型，通过Boolean对象都会转换为假值，而通过==判断三者的关系，他们总是相等的，因为在比较值时它们会因为类型不同而都被转换为false值：1console.log((false == 0) &amp;&amp; (0 == &apos;&apos;) &amp;&amp; (&apos;&apos; == false)) // true 或者有时候我们希望利用强转特性比较字符串与数字：12console.log(11 == &apos;11&apos;) // trueconsole.log(11 === &apos;11&apos;) // false ^按位异或运算符，对比每一个比特位，当比特位不相同时则返回1，否则返回0。很少人在Web开发中使用此运算符吧，除了传说中的一种场景：交换值。 若要交换a与b的值，如果可以的话推荐你使用：1[a, b] = [b, a]; 或者新建一个c，用于存储临时变量，如果你遇到有人这样书写：1234// 异或运算，相同位取0，不同位取1，a ^ b ^ b = a， a ^ a ^ b = ba = a ^ bb = a ^ ba = a ^ b 这样通过异或运算进行交换两个数字型变量，请原谅他并忽视它，他只可能是一个醉心于魔法的初心者，并祝愿他早日发现，简洁易读的函数才是最佳实践。 ..&emsp;&emsp;在JavaScipt整数和浮点数都属于Number类型，所有数字都以64位浮点数的形式储存，因此在解析语句时允许数组后面跟着一个小数点（1. === 1），可这样其实会引发一个问题，解释器无法解析1.toString()这样的语句，会抛出：Uncaught SyntaxError，此时表达式中的 . 并没有视为属性访问器，而是与1结合为浮点数1. ，所以程序会报错，1. toString()等同于1toString()。 &emsp;&emsp;为了更便于理解，可以记住这个规则：在解释器眼中，Number型表达式的出现的第一个.为浮点数的小数分隔符号，第二个.为属性访问器。比如1.0.toString()与1. .toString()这样的语法都能正常执行。需要注意的是变量与表达式的区别，若将Number型表达式赋值给变量，通过变量是可以直接调用原型方法的，因为此时的 . 没有歧义。 &emsp;&emsp;这样的松散类型结构确实很使人产生误解，在程序中我们都应该规避这样的歧义性语句，通过括号消除数值表达式的歧义(1).toString()，而不是为了耍酷使用1. .toString( )。 void&emsp;&emsp;根据MDN中的定义：void对给定的表达式进行求值，然后返回undefined，我们可以有很多种方式去理解这句话。 &emsp;&emsp;首先它可以作为undefined的替代品，由于undefined不是保留字，它其实是一个全局变量值，因此我们可以对其进行改变，程序可能会出现不稳定的状态，在ES5中已经是一个只读属性了，但是在局部作用域中，还是有被重载的可能（你可能也有被害妄想症）：1234(function() &#123; const undefined = &apos;hello&apos;; console.log(undefined); // hello&#125;)(); &emsp;&emsp;其次，我们可以在函数前面加上void关键字，表示函数没有返回值，但是不必在每一个函数都加上，这不符合JavaScript的代码风格，利用此特性我们可以用于执行IIFE（立即执行函数），让我们来看以下示例：1234const arrs = [](function() &#123; console.log(&apos;hello&apos;)&#125;)() &emsp;&emsp;若你不习惯于写分号，那就极有可能遇到过这种报错：Uncaught TypeError: [] is not a function，这是由于编辑器在进行minify的时候无法进行正确的分词，这时通过void就可以解决此类问题，解决了分词的问题，也使立即执行函数调用更加优雅：1234const arrs = []void function() &#123; console.log(&apos;hello&apos;)&#125;() 在有时我们不希望a标签进行跳转，以下是一些常用方法：12345678&lt;!-- 使用 preventDefault --&gt;&lt;a id=&quot;a&quot; href=&quot;&quot;&gt;hello&lt;/a&gt;&lt;script&gt; a.addEventListener(&apos;click&apos;, e =&gt; e.preventDefault());&lt;/script&gt;&lt;!-- 使用return false --&gt;&lt;a href=&quot;&quot; onclick=&quot;return false;&quot;&gt;hello&lt;/a&gt; 数值表示法3e9 &emsp;&emsp;科学计数法是一种数学术语，将一个数表示为a乘以10的n次方，如光速30万公里每秒，在计算中通常将米做单位，则记为：300000000m/s，而在JavaScript中我们可使用科学计数法 3e9表示。 在这里举几个科学计数法的示例：1231e5; // 1000002e-4; // 0.0002-3e3; // -3000 &emsp;&emsp;Number对象有toExponential(fractionDigits)方法以科学计数法返回该数值的字符串表示形式，参数fractionDigits可选，用于用来指定小数点后有几位数字，例如：(179000).toExponential(); // “1.79e+5”。 以下情况JavaScript会自动将数值转为科学计数法表示： &emsp;&emsp;1.小数点前的数字多于21位。 &emsp;&emsp;2.数值小于1且小数点后的零多于5个，如0.0000001。 .5px &emsp;&emsp;通常某些人习惯省略0.开头的数字，常见于数值计算、css属性中，比如0.5px可直接写为.5px，0.2 / 0.3可写为： .2 / .3 0x、0o和0b &emsp;&emsp;在十进制的世界里呆久了，请不要忘记还有其他进制的存在，在计算机中它们是同地位的。JavaScript提供了以下进制的表示方法： 二进制：只用0和1两个数字，前缀为0b，十进制13可表示为0b1101 八进制：只用0到7八个数字，前缀为0o、0，十进制13可表示为0o15、015 十六进制：只用0到9的十个数字，和a到f六个字母，前缀为0x，十进制13可表示为0xd &emsp;&emsp;默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制再进行运算。从十进制转其他进制请查阅toString()方法，从其他进制转十进制请查阅parseInt()方法，从其他进制转其他进制请先转为十进制再转为其他方法。 1.“话术”Array.prototype.sort&emsp;&emsp;Array.prototype.sort()默认根据字符串的Unicode编码进行排序，具体算法取决于实现的浏览器，在v8引擎中，若数组长度小于10则使用从插入排序，大于10使用的是快排。 &emsp;&emsp;而sort支持传入一个compareFunction(a, b)的参数，其中a、b为数组中进行比较的两个非空对象(所有空对象将会排在数组的最后)，具体比较规则为： 返回值小于0，a排在b的左边 返回值等于0，a和b的位置不变 返回值大于0，a排在b的右边 因此利用sort即可写一个打乱数组的方法：1[1,2,3,4].sort(() =&gt; .5 - Math.random()) &emsp;&emsp;但是以上的实现并不是完全随机的，究其原因，还是因为排序算法的不稳定性，导致一些元素没有机会进行比较，具体请参考问题，在抽奖程序中若要实现完全随机，请使用 Fisher–Yates shuffle 算法，以下是简单实现：123456function shuffle(arrs) &#123; for (let i = arrs.length - 1; i &gt; 0; i -= 1) &#123; const random = Math.floor(Math.random() * (i + 1)); [arrs[random], arrs[i]] = [arrs[i], arrs[random]]; &#125;&#125; Array.prototype.concat.apply&emsp;&emsp;apply接收数组类型的参数来调用函数，而concat接收字符串或数组的多个参数，因此可使用此技巧将二维数组直接展平：1Array.prototype.concat.apply([], [1, [2,3], [4]]) 而通过此方法也可以写一个深层次遍历的方法：1234567function flattenDeep(arrs) &#123; let result = Array.prototype.concat.apply([], arrs); while (result.some(item =&gt; item instanceof Array)) &#123; result = Array.prototype.concat.apply([], result); &#125; return result;&#125; 经过测试，效率与lodash对比如下: 对上述方法中的Array.prototype.concat.apply([ ], target)亦可以写成：[ ].concat(…target)。 Array.prototype.push.apply在es5中，若想要对数组进行拼接操作，我们习惯于使用数组中的concat方法：12let arrs = [1, 2, 3];arrs = arrs.concat([4,5,6]); 但还有酷的方法，利用apply方法的数组传参特性，可以更简洁的执行拼接操作：12const arrs = [1, 2, 3];arrs.push.apply(arrs, [4, 5, 6]); Array.prototype.length它通常用于返回数组的长度，但是也是一个包含有复杂行为的属性，首先需要说明的是，它并不是用于统计数组中元素的数量，而是代表数组中最高索引的值：123const arrs = [];arrs[5] = 1;console.log(arrs.length); // 6 另外，length长度随着数组的变化而变化，但是这种变化仅限于：子元素最高索引值的变化，假如使用delete方法删除最高元素，length是不会变化的，因为最高索引值也没变：12const arrs = [1, 2, 3];delete arrs[2]; // 长度依然为3 length还有一个重要的特性，那就是允许你修改它的值，若修改值小于数组本身的最大索引，则会对数组进行部分截取：123const arrs = [1, 2, 3, 4];arrs.length = 2; // arrs = [1, 2]arrs.length = 0; // arrs = [] 若赋予的值大于当前最大索引，则会得到一个稀疏数组：12const arrs = [1, 2];arrs.length = 5; // arrs = [1, 2,,,,] 若将值赋为0，则执行了清空数组的操作:12const arrs = [1, 2, 3, 4];arrs.length = 0; // arrs = [] 使用此方法会将数组中的所有索引都删除掉，因此也会影响其他引用此数组的值，这点跟使用arrs = []有很大的区别：1234567let a = [1,2,3];let b = [1,2,3];let a1 = a;let b1 = b;a = [];b.length = 0;console.log(a, b, a1, b1); // [], [], [1, 2, 3], [] 在对length进行修改的时候，还需要注意： 值需要为正整数 传递字符串会被尝试转为数字类型 Object.prototype.toString.call&emsp;&emsp;每个对象都有一个toString()，用于将对象以字符串方式引用时自动调用，如果此方法未被覆盖，toString则会返回[object type]，因此Object.prototype.toString.call只是为了调用原生对象上未被覆盖的方法，call将作用域指向需要判断的对象，这样一来就可以通过原生的toString方法打印对象的类型字符串： Object.prototype.toString.call([]) =&gt; “[object Array]”，利用这个特性，可以较为精确的实现类型判断。 &emsp;&emsp;在ES3中，获取到的type为内部属性[[Class]]属性，它可以用来判断一个原生属性属于哪一种内置的值；在ES5中新增了两条规则：若this值为null、undefined分别返回： [object Null]、[object Undefined]；在ES6中不存在[[Class]]了，取而代之的是一种内部属性：[[NativeBrand]]，它是一种标记值，用于区分原生对象的属性，具体的判断规则为：12345678910111213141516171819202122232419.1.3.6Object.prototype.toString ( )When the toString method is called, the following steps are taken:If the this value is undefined, return &quot;[object Undefined]&quot;.If the this value is null, return &quot;[object Null]&quot;.Let O be ! ToObject(this value).Let isArray be ? IsArray(O).If isArray is true, let builtinTag be &quot;Array&quot;.Else if O is a String exotic object, let builtinTag be &quot;String&quot;.Else if O has a [[ParameterMap]] internal slot, let builtinTag be &quot;Arguments&quot;.Else if O has a [[Call]] internal method, let builtinTag be &quot;Function&quot;.Else if O has an [[ErrorData]] internal slot, let builtinTag be &quot;Error&quot;.Else if O has a [[BooleanData]] internal slot, let builtinTag be &quot;Boolean&quot;.Else if O has a [[NumberData]] internal slot, let builtinTag be &quot;Number&quot;.Else if O has a [[DateValue]] internal slot, let builtinTag be &quot;Date&quot;.Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be &quot;RegExp&quot;.Else, let builtinTag be &quot;Object&quot;.Let tag be ? Get(O, @@toStringTag).If Type(tag) is not String, set tag to builtinTag.Return the string-concatenation of &quot;[object &quot;, tag, and &quot;]&quot;.This function is the %ObjProto_toString% intrinsic object.NOTEHistorically, this function was occasionally used to access the String value of the [[Class]] internal slot that was used in previous editions of this specification as a nominal type tag for various built-in objects. The above definition of toString preserves compatibility for legacy code that uses toString as a test for those specific kinds of built-in objects. It does not provide a reliable type testing mechanism for other kinds of built-in or program defined objects. In addition, programs can use @@toStringTag in ways that will invalidate the reliability of such legacy type tests. Object.create(null)&emsp;&emsp;用于创建无“副作用”的对象，也就是说，它创建的是一个空对象，不包含原型链与其他属性。若使用const map = {}创建出来的对象相当于Object.create(Object.prototype)，它继承了对象的原型链。 JSON.parse(JSON.stringify(Obj))&emsp;&emsp;很常用的一种深拷贝对象的方式，将对象进行JSON字符串格式化再进行解析，即可获得一个新的对象，要注意它的性能不是特别好，而且无法处理闭环的引用，比如：123const obj = &#123;a: 1&#125;;obj.b = obj;JSON.parse(JSON.stringify(obj)) // Uncaught TypeError: Converting circular structure to JSON &emsp;&emsp;这样通过JSON解析的方式其实性能并不高，若对象可通过浅拷贝复制请一定使用浅拷贝的方式，不管你使用{…obj}还是Object.assign({}, obj)的方式，而如果对性能有要求的情况下，请不要再造轮子了，直接使用npm:clone这个包或是别的吧。 生成[0, 1, …, N-1]&emsp;&emsp;依稀记得在Python中生成列表的语法是多么简洁：[ x for x in range(1, 10) ]，那么在JavaScript如何进行初始化1~10的有序序列呢？ &emsp;&emsp;行车有规范，直接使用new Array(10)进行初始化并.map是不可取的，因为这样只设置了数组的length字段：123Object.getOwnPropertyNames([1, 2, 3]) // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;length&quot;]const a = new Array(3) // [undefined, undefined, undefined]Object.getOwnPropertyNames(a) // [&quot;length&quot;] 这样会导致map、filter等迭代方法无效，当然使用fill填充后即可正常操作数组项，但是在这里会用其他方法解决。 &emsp;&emsp;在以前，大家喜欢使用这样的Hack技巧去初始化固定长度的数组：Array.apply(null, { length: 3 })，需要特意说明的是，{ length: 3 }其实是一个类数组对象，Array.prototype.apply内部取参数可能是这样实现的:123for (let index = 0; i &lt; arguments[1].length; index++) &#123; // pass arguments[1][index]&#125; 正因如此，如果你基础没问题的话，就会发现上面的语句其实等效于：Array(undefined, undefined, undefined)，综上，生成0~10的序列语句可写为：1Array.apply(null, &#123; length: 10 &#125;).map((v, k) =&gt; k) 而对于ES6来讲，完全可以用Array.from来替代以上的语句的：1Array.from(new Array(10), (k, v) =&gt; v) Array.from不仅接受字符串、Set、Map、类数组对象作为参数，凡是可迭代对象都可以，比如我们出于娱乐的目的使用生成器实现：1234567function* range(start, end) &#123; for (let i = start; i &lt; end; i++) &#123; yield i &#125;&#125;Array.from(range(1, 10)) // [1, 2, 3, 4, 5, 6, 7, 8, 9][...range(1, 10)] // [1, 2, 3, 4, 5, 6, 7, 8, 9] 1.“理论”Truthy与Falsy&emsp;&emsp;对每一个类型的值来讲，它每一个对象都有一个布尔型的值，Falsy表示在Boolean对象中表现为false的值，在条件判断与循环中，JavaScript会将任意类型强制转化为Boolean对象。以下这些对象在遇到if语句时都表现为Falsy：12345678if (false)if (null)if (undefined)if (0)if (NaN)if (&apos;&apos;)if (&quot;&quot;)if (document.all) &emsp;&emsp;document.all属于历史遗留原因，所以为false，它违背了JavaScript的规范，可以不管它，而NaN这个变量，千万不要用全等或相等对其进行判断，因为它发起疯来连自己都打：123console.log(NaN === 0) // falseconsole.log(NaN === NaN) // falseconsole.log(NaN == NaN) // false &emsp;&emsp;但是我们可以使用Object.is方法进行判断值是否为NaN，它是ES6新加入的语法，用于比较两个值是否相同，它可以视为比全等判断符更为严格的判断方法，但是不可混为一谈：12Object.is(NaN, NaN) // trueObject.is(+0, -0) // false 而除了Falsy值，所有值都是Truthy值，在Boolean上下文中表现为true。 以上总结了JavaScript中一些自己接触过到的Trick技巧，并简单阐述使用规范，因为本文以总结为主，所以并没有将许多有价值的知识点进行展开，有需求的朋友只能自助了。如果文中有错误或不足的地方还望多多包涵并提给我，谢谢。 参考资料： https://modernweb.com/45-useful-javascript-tips-tricks-and-best-practices/ https://dmitripavlutin.com/the-magic-behind-array-length-property/ https://stackoverflow.com/questions/7310109/whats-the-difference-between-and-in-javascript http://javascript.ruanyifeng.com/grammar/number.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的生活]]></title>
    <url>%2F2019%2F07%2F21%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[如果没有程序员，整个虚拟世界都会消失不见。1全中国7亿多网民，再也不能愉快滴发自拍，看视频，打游戏，甚至连打电话都成了一种幻想。绝大部分电子设备都会变成废铁，人类的生活将完全倒退到70多年以前。 程序员贡献了自己的聪明才智，但他们当中的大部分人都时刻承担着超出常人的压力，付出了常人难以忍受的高强度劳动。 “十年编程两茫茫，工期短，需求长。千行代码，Bug何处藏。纵使上线又如何，新版本，继续忙。黑白颠倒没商量，睡地铺，吃食堂。夜半梦醒，无人在身旁。最怕灯火阑珊时，手机响，心里慌。程序员注定是不被理解的那群人吗？不，我想用几个漫画小故事和大家说：如果你是程序员，那每一天将会怎样度过。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用教程]]></title>
    <url>%2F2019%2F07%2F19%2FGit%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[写在前面的话网上关于git的教程数不胜数，之前用”傻瓜式”的Sourcetree推送代码，被老板严重批评，所以也是硬着头皮去学了下git，写这篇文章的目的，一来是为了总结刚学习的内容（毕竟“好记性不如烂笔头”），二来是为了总结一下常用的命令便于查阅。git：分布式的版本管理系统，一般的开发模式：(如果是开发人员，忽略此步骤。)项目开始阶段，初始化项目（init），提交本地的代码到仓库，将本地仓库的代码推送到远端库（push）； 项目开发人员从远端库克隆代码到本机（clone），此时本地仅有一个master分支；新建dev分支并切换、在Dev分支中进行开发工作，其实就是修改并提交代码（add+commit）；当开发的dev分支的代码没问题时，将dev分支合并（merge）到master；将master推送到远端分支，至此，其他的项目开发人员就可以查看到你提交的代码了！ dev分支也可以是修复某个bug或者为了开发某个issue建立的，当bug已经修复或issue开发完成时，把dev合并到master之后，就可以把它删除了。 常用的git命令 git init git 初始化 git config –global user.name “xxx” 配置用户名 git config –global user.email “xxx@xxx.com“ 配置邮件 git add git add . 把所有变化提到暂存区 git add xxx 把制定文件提到暂存区 git status 查看当前文件状态 git commit -m “” 提交更新 git commit -am ‘xxx’ 将add和commit合为一步, 但只能cover到已被track的文件 git show commit_id 显示某个提交的详细内容 git log 查看commit日志 git reset –hard commit_id 回退到某个commit git revert commit_id 进入到某个commit的代码，并生成新的commit git remote -v 查看本地关联的远程仓库 git remote add xxx 地址 关联远程仓库，名字为xxx git remote rename oldname newname 修改远程仓库的名字 git remote rm name 删除名字为name的远程仓库的关联 git pull name branch 拉取名字为name的远程仓库的branch分支 git push name branch 推送名字为name的远程仓库的branch分支 git checkout -b branch [remote/master] 新建并进入一个名字为branch的分支 可选参数指在某个分支基础上新建 git checkout branch 切到名字为branch的分支 git branch -D branch 删除名字为branch的分支 git branch -a 查看所有分支 包括本地和远程 git clone 地址 克隆项目到本地 git fetch [name] [branch] 将获取远程仓库的更新取回本地，取回的代码对本地的开发代码没有影响，无参数时默认取所有 git merge branch 把branch分支合并到当前分支 git push name :branch 删除名字为name的远程的branch分支 git rebase -i HEAD~x 或 git rebase -i commi_id (commi_id不参与合并的) 合并多个commit, pick改为s, 如有冲突，解决以后继续 git add . git rebase –continue 取消合并 git rebase –abort git tag name [commit_id] 增加名字为name的tag, commit_id制定commit处打tag git tag 查看所有tag，按字母排序 git tag -d name 删除名字为name的tag git push origin tagname 把名字为tagname的tag推到远程 git push –tags 把所有tag推送到远程仓库 git push origin :refs/tags/ 删除远程tag 更详细的教程请参考这里]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客美化]]></title>
    <url>%2F2019%2F07%2F17%2Fhexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[各种功能不定时更新中本文将讲述一些Hexo博客的美化，不同主题可能方法有些不同实际效果欢迎访问我的博客：https://www.xiaomujin.club/ 进行查看，本文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 文章目录：– 添加卡通人物（看板娘） – 添加鼠标点击爱心效果 – 添加鼠标点击显示字体效果 – 添加鼠标点击烟花爆炸效果 – 添加彩色滚动变换字体 – 添加背景音乐 – 背景添加动态线条效果 – 添加人体时钟等有趣的挂件 – 添加背景动态彩带效果 – 添加背景代码雨特效 – 添加卡通人物（看板娘）我在逛别人博客的时候偶然发现右下角居然有一个萌萌的卡通人物，还能根据你鼠标位置摇头，瞬间被吸引到了，赶紧也给自己博客添加一个吧！点击此处进入该项目地址在博客文件夹输入如下命令获取 live2d ： npm install --save hexo-helper-live2d 输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请点击此处，各个模型的预览请访问原作者的博客 npm install packagename 打开站点目录下或者主题目录的 _config.yml 文件，添加如下代码： live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 设置好过后我们就拥有了一个卡通人物 – 添加鼠标点击爱心效果! function(e, t, a) { function n() { c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;), o(), r() } function r() { for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) } function o() { var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) { t &amp;&amp; t(), i(e) } } function i(e) { var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, d.push({ el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() }), t.body.appendChild(a) } function c(e) { var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try { a.appendChild(t.createTextNode(e)) } catch (t) { a.styleSheet.cssText = e } t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) } function s() { return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; } var d = []; e.requestAnimationFrame = function() { return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) { setTimeout(e, 1e3 / 60) } }(), n() }(window, document); 在 \themes\yilia\layout\layout.ejs 文件末尾添加以下代码： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt; 完成以上操作后，当我们点击鼠标的时候就可以看见爱心的特效了 – 添加鼠标点击显示字体效果在 /themes/yilia/source/js 下新建文件 click_show_text.js，在 click_show_text.js 文件中添加以下代码：： var a_idx = 0; jQuery(document).ready(function($) { $(&quot;body&quot;).click(function(e) { var a = new Array (&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;); var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ &quot;z-index&quot;: 5, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#FF0000&quot; }); $(&quot;body&quot;).append($i); $i.animate({ &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 }, 3000, function() { $i.remove(); }); }); setTimeout(&apos;delay()&apos;, 2000); }); function delay() { $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;); } 其中的社会主义核心价值观可以根据你自己的创意替换为其他文字，然后在 \themes\yilia\layout\layout.ejs 文件末尾添加以下代码： &lt;!--单击显示文字--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/click_show_text.js&quot;&gt;&lt;/script&gt; 最终实现效果如下: – 添加鼠标点击烟花爆炸效果在 \themes\yilia\source\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码： &quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}; 然后在 \themes\yilia\layout\layout.ejs 文件中写入以下代码： &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt; 最终效果： – 添加彩色滚动变换字体在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改： &lt;div id=&quot;binft&quot;&gt;&lt;/div&gt; &lt;script&gt; var binft = function (r) { function t() { return b[Math.floor(Math.random() * b.length)] } function e() { return String.fromCharCode(94 * Math.random() + 33) } function n(r) { for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) { var l = document.createElement(&quot;span&quot;); l.textContent = e(), l.style.color = t(), n.appendChild(l) } return n } function i() { var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : &quot;forward&quot; === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = &quot;backward&quot;, c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = &quot;forward&quot;)), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) } var l = &quot;&quot;, o = [&quot;青青陵上柏，磊磊涧中石。&quot;, &quot;人生天地间，忽如远行客。&quot;,&quot;斗酒相娱乐，聊厚不为薄。&quot;, &quot;驱车策驽马，游戏宛与洛。&quot;,&quot;洛中何郁郁，冠带自相索。&quot;,&quot;长衢罗夹巷，王侯多第宅。&quot;,&quot;两宫遥相望，双阙百余尺。&quot;,&quot;极宴娱心意，戚戚何所迫？&quot;].map(function (r) { return r + &quot;&quot; }), a = 2, g = 1, s = 5, d = 75, b = [&quot;rgb(110,64,170)&quot;, &quot;rgb(150,61,179)&quot;, &quot;rgb(191,60,175)&quot;, &quot;rgb(228,65,157)&quot;, &quot;rgb(254,75,131)&quot;, &quot;rgb(255,94,99)&quot;, &quot;rgb(255,120,71)&quot;, &quot;rgb(251,150,51)&quot;, &quot;rgb(226,183,47)&quot;, &quot;rgb(198,214,60)&quot;, &quot;rgb(175,240,91)&quot;, &quot;rgb(127,246,88)&quot;, &quot;rgb(82,246,103)&quot;, &quot;rgb(48,239,130)&quot;, &quot;rgb(29,223,163)&quot;, &quot;rgb(26,199,194)&quot;, &quot;rgb(35,171,216)&quot;, &quot;rgb(54,140,225)&quot;, &quot;rgb(76,110,219)&quot;, &quot;rgb(96,84,200)&quot;], c = { text: &quot;&quot;, prefixP: -s, skillI: 0, skillP: 0, direction: &quot;forward&quot;, delay: a, step: g }; i() }; binft(document.getElementById(&apos;binft&apos;)); &lt;/script&gt; 最终效果： – 添加背景音乐打开网页版网易云音乐，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码然后将此代码放到你想要放的地方，比如放在博客的左侧，则打开 \yilia\layout_partial\left-col.ejs 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 auto=1 表示打开网页自动播放音乐，auto=0 表示关闭自动播放音乐。 – 背景添加动态线条效果在 \themes\yilia\layout\layout.ejs 文件中添加如下代码： &lt;!--动态线条背景--&gt; &lt;script type=&quot;text/javascript&quot; color=&quot;220,220,220&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt; &lt;/script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 最终实现效果： – 添加人体时钟等有趣的挂件无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的。 实现代码： &lt;!--人体时钟背景透明--&gt; &lt;script charset=&quot;Shift_JIS&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js&quot;&gt;&lt;/script&gt; &lt;!--人体时钟背景白--&gt; &lt;script charset=&quot;Shift_JIS&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js&quot;&gt;&lt;/script&gt; 其他网页小挂件推荐： http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 – 添加背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带。 实现方法：在 \themes\yilia\layout\layout.ejs 文件的body前面添加如下代码： &lt;!-- 样式一（鼠标点击更换样式） --&gt; &lt;script src=&quot;https://g.joyinshare.com/hc/ribbon.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;!-- 样式二（飘动的彩带） --&gt; &lt;script src=&quot;https://g.joyinshare.com/hc/piao.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; – 添加背景代码雨特效在 \themes\yilia\source\js新建DigitalRain.js，写入以下代码： window.onload = function(){ //获取画布对象 var canvas = document.getElementById(&quot;canvas&quot;); //获取画布的上下文 var context =canvas.getContext(&quot;2d&quot;); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++){ drops.push(0); } //运动的文字 var str =&quot;WELCOME TO WWW.ITRHX.COM&quot;; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw(){ context.fillStyle = &quot;rgba(238,238,238,.08)&quot;;//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = &quot;600 &quot;+fontSize+&quot;px Georgia&quot;; //给字体添加颜色 context.fillStyle = [&quot;#33B5E5&quot;, &quot;#0099CC&quot;, &quot;#AA66CC&quot;, &quot;#9933CC&quot;, &quot;#99CC00&quot;, &quot;#669900&quot;, &quot;#FFBB33&quot;, &quot;#FF8800&quot;, &quot;#FF4444&quot;, &quot;#CC0000&quot;][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++){ var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99){ drops[i] = 0; } drops[i]++; } }; function randColor(){//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;; } draw(); setInterval(draw,35); }; 在主题文件的相关css文件中（以 yilia 主题为例，在\themes\yilia\source-src\less_main.less 文件末尾）添加以下代码： canvas { position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1; } 然后在主题的 layout.ejs 文件中引入即可： &lt;!-- 数字雨 --&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;1440&quot; height=&quot;900&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/DigitalRain.js&quot;&gt;&lt;/script&gt; 最终效果： 未完持续更新……]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己学习vue所踩过的坑]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%AD%A6%E4%B9%A0vue%E6%89%80%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1.前言之前学习了Vue前端框架,真的是蒙着眼胡乱摸索，各种各样奇奇怪怪的报错，不过后来基本都解决了，作为一个web的菜鸟,在学习的过程中,网上有些技术博客往往没有什么可以借鉴的地方,在这里，我特意将我的学习过程记录下来。希望看到我的文章的朋友们能够少走点弯路。 2.开发依赖工具2.1 node.js 2.2 git 2.3 Visual Studio Code 3.代码3.1 安装node.js node.js在百度上搜索一共有两个网址:http://nodejs.cn/download/ 和https://nodejs.org/en/ 前面的url是中文网的地址,后面的是官网的地址。中文网的node版本会比官网的版本低,最起码现在是这样。我使用的是最新版本v12.2.0 在官网下载的,安装流程就不说了。一路向下就行,很粗暴的。安装完毕后,在终端运行 node -v 和npm -v 检查是否成功安装。 由于node安装插件是从国外服务器下载，受网络影响大，速度慢且可能出现异常；这里建议使用cnpm。在终端输入：npm install -g cnpm –registry=https://registry.npm.taobao.org 3.2 安装git git官网下载地址:https://git-scm.com/download/win,下载完毕后进行安装,也是一路向下,没有需要注意的地方。安装完毕 ,右击你的桌面空白处会出现两个入口。======&gt; 常用的git bash here 是用来下载vue-cli的模板,以及启动项目的。其他用途请自行百度。 3.3 安装 Visual Studio Code 这是一个编辑器,前端有很多编辑器,可以根据自己的喜好来。我比较喜欢这个的代码错误提示:ESLint,当然里面还有很多其他丰富快捷的插件，根据自己的需求来下载。下载地址:https://code.visualstudio.com/ 3.4项目搭建 vue项目我使用的是webpack的模板,有关打包的问题，有时间再讲讲。1.首先是安装vue-cli脚手架npm install -g vue-cli2.查看vue-cli的版本，这里需要注意的是,V是大写的。vue -V3.下载模板。vue init webpack my-project 初始化用webpack打包的项目,my-project是项目名称 会出现以下步骤。 上面主要是项目的一些描述和基本配置。可以按照我上面的进行配置。这里之前遇到过问题就是初始化项目的时候,报错404。 这个问题是版本问题,更换下vue-cli的版本就可以了,出现这个问题就多试试版本 毕竟好事多磨嘛。版本问题解决了之后,可能会出现一些其他问题,比如初始化模板的时候页面卡住。流程不走。这是因为网上有许多windows下的命令行工具,比如MobaXterm这个工具。我之前出现过页面卡住的原因就是因为使用了这个工具。具体原因不明。后来使用了git bash here 解决了页面卡住的问题。 4.安装依赖,运行vue项目进入项目文件夹：$ cd my-project$ npm install$ npm run dev成功后会出现: 在地址栏输入 http://localhost:8080 会看到下面的页面 至此恭喜你,vue项目搭建成功了，vue这条路还有很长，以后也会记录相关技术的使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>菜鸟进阶</tag>
      </tags>
  </entry>
</search>
